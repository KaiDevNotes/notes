В ОСНОВЕ ЛЕЖИТ КОНЦЕПЦИЯ "TDD" (см. TDD - 2 layers.png):

1 - Пишем "провальный" приемочный тест 
(Write failing acceptance test)

2 - Определяем наменьшую единицу функциональности и пишем под нее тест 
(Write a failing unit test)

3 - Пишем самую простую реализацию, кот. успешно пройдет созданный unit тест
(Make the test pass)

4 - Рефакторим реализацию 
(Refactor)

-------------------------------------------------------------------------------

ЕСЛИ ПЕРЕФРАЗИРОВАТЬ, ТО ПОЛУЧАЕМ СЛУДУЮЩЕЕ:

1 - Определяем НАМЕНЬШУЮ (ЭЛЕМЕНТАРНЕЙШУЮ) единицу функциональности, 
которую можно протестировать Unit-тестом.

2 - Пишем под нее Unit-тест.

3 - Реализуем эту функциональность в виде класса, кот. удовлетворяет тесту.
Таким образом, мы получает самую БАЗОВУЮ (нижнюю) единицу функциональности.

4 - Продлжаем проектирование методом СНИЗУ-ВВЕРХ (buttom-up), т.е. проектируем 
финальность, кот. использует данную функциональность.
Т.е. пишем под нее Unit-тест и далее ее реализацию, кот. удовлетворяет тесту.

------------------------------------------------------------------------------

Данная последовательность позволяет выделять отдельные наименьшие части функцональности,
инкапсулировать и тестировать их. 

Что в свою очередь способствует качественной демпозиции, т.е.разбиению системы на части 
и назначению этим частям необходимых функций.

Таким образом мы можем выделить наиболее элементарные компоненты системы, кот. далее будут 
использоваться более сложными компонентами.
