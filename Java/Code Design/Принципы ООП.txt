Head First. Паттерны проектирования. Э. Фримен., 2011 год


Базовые принципы ООП (стр. 624):

- Инкапсулируйте то, что изменяется
- Предпочитайте композицию наследованию
- Программируйте на уровне интерфейсов
- Код должен зависеть от абстракции (интерфейс, абстр. класс), а не от конкретных классов
- Стремитесь к слабой связности взаимодействующих обектов 
- Классы должны быть открытыми для расширения, но закрытыми для изменения
- Взаимодействуйте только с "друзьями"
- Не вызывайте нас - мы вас сами вызовем
- Класс должен иметь только одну обязанность (только одну причину для изменения)


-- Всегда выбирайте самое простое решение, соответствующие вашим потребностям, даже если в нем не используются паттерны проектирования
-- Не используйте паттерны проектирования только ради их использования
-- Решение об использовании должно естественно следовать из архитектуры на основе вышеизложенных принципов

----------------------------------------------------------------------------------


SRP, High Cohesion, Low Coupling


Эти 3 принципа тесно связаны и один является следствием 2ух других. 

	SRP (Single Responsibility Principle) - простыми словами метод/класс/пакет/модуль
	должен иметь одну обязанность (одну причину для изменения).

	High Cohesion (высокое внутреннее зацепление - согласованность) - если SRP выполняется на 
	уровне класса/пакета/модуля, то это приводит к тому, что все связанные данные и обязанности 
	распологаются в одном месте (классе/пакете/модуле).
	
	Low Coupling (низкая внешняя зависимость) - если все связанные данные и обязанности 
	распологаются в одном месте (классе/пакете/модуле), то это приводит к снижению количества 
	внешних зависимостей с другими классами/модулями. 
	Т.е. все необходимое для реализации определенных обязанностей (функционала) находится в одном месте. 

----------------------------------------------------------------------------------------


ПОЛИМОРФИЗМ - возможность использовать объекты разных типов, как-будто это объекты одного 
и того же типа. 

Т.е. данные объекты реализуют один и тот же интерфейс или расширяют один 
и тот же родительский класс, и мы можем работать с этими объектами одинаковым образом 
через ссылку, которыя имеет тип реализуемого интерфейса или расширяемого родительского 
класса. 

----------------------------------------------------------------------------------------


Назначение самых распространенных паттернов (стр. 626):

- СТРАТЕГИЯ (Strategy) - инкапсулирует взаимозаменяемые варианты поведения и выбирает один из них посредством делегирования

- НАБЛЮДАТЕЛЬ (Observer) - обеспечивает оповещение объектов об изменении состояния

- ДЕКОРАТОР (Decorator) - упаковывает объект для реализации нового поведения

- ФАБРИЧНЫЙ МЕТОД (Factory Method) - субклассы решают, какие конкретные классы должны создаваться 

- АБСТРАКТНАЯ ФАБРИКА (Abstract Factory) - позволяет клиенту создавать семейства объектов без указания их конкретных классов

- ОДИНОЧКА (Sigleton) - обеспечивает создание только одного экземпляра класса

- КОМАНДА (Command) - инкапсулирует запрос (вызов) в виде объекта

- АДАПТЕР (Adapter) - упаковывает объект и предоставляет другой интерфейс к нему

- ФАСАД (Facade) - упрощает интерфейс группы классов

- ШАБЛОННЫЙ МЕТОД (Template Method) - субклассы решают, как реализовать шаги в алгоритме (инкапсуляция алгоритма)

- ИТЕРАТОР (Iterator) - обеспечивает механизм перебора коллекции объектов без раскрытия ее реализации (инкапсуляция механизма перебора элементов разных коллекций объектов)

- КОМПОНОВЩИК (Composite) - клиент получает возможность выполнять однородные операции как с объектами, так и с коллециями этих объектов

- СОСТОЯНИЕ (State) - инкапсулирет поведение, связанное с состоянием, с делегированием поведения объекту текущего состояния

- ЗАМЕСТИТЕЛЬ (Proxy) - упаковывает объект для управления достуом к нему




По остальным паттернам смотрим сюда:
Паттерны проектирования. Э. Гамма, Р. Хелм, Р. Джонсон, Д. Влиссидес, 2010




