Head First. Паттерны проектирования. Э. Фримен., 2011 год


Базовые принципы ООП (стр. 624):

- Инкапсулируйте то, что изменяется
- Предпочитайте композицию наследованию
- Программируйте на уровне интерфейсов
- Код должен зависеть от абстракции (интерфейс, абстр. класс), а не от конкретных классов
- Стремитесь к слабой связности взаимодействующих обектов 
- Классы должны быть открытыми для расширения, но закрытыми для изменения
- Взаимодействуйте только с "друзьями"
- Не вызывайте нас - мы вас сами вызовем
- Класс должен иметь только одну обязанность (только одну причину для изменения)


-- Всегда выбирайте самое простое решение, соответствующие вашим потребностям, даже если в нем не используются паттерны проектирования
-- Не используйте паттерны проектирования только ради их использования
-- Решение об использовании должно естественно следовать из архитектуры на основе вышеизложенных принципов

----------------------------------------------------------------------------------


Назначение самых распространенных паттернов (стр. 626):

- СТРАТЕГИЯ (Strategy) - инкапсулирует взаимозаменяемые варианты поведения и выбирает один из них посредством делегирования

- НАБЛЮДАТЕЛЬ (Observer) - обеспечивает оповещение объектов об изменении состояния

- ДЕКОРАТОР (Decorator) - упаковывает объект для реализации нового поведения

- ФАБРИЧНЫЙ МЕТОД (Factory Method) - субклассы решают, какие конкретные классы должны создаваться 

- АБСТРАКТНАЯ ФАБРИКА (Abstract Factory) - позволяет клиенту создавать семейства объектов без указания их конкретных классов

- ОДИНОЧКА (Sigleton) - обеспечивает создание только одного экземпляра класса

- КОМАНДА (Command) - инкапсулирует запрос (вызов) в виде объекта

- АДАПТЕР (Adapter) - упаковывает объект и предоставляет другой интерфейс к нему

- ФАСАД (Facade) - упрощает интерфейс группы классов

- ШАБЛОННЫЙ МЕТОД (Template Method) - субклассы решают, как реализовать шаги в алгоритме (инкапсуляция алгоритма)

- ИТЕРАТОР (Iterator) - обеспечивает механизм перебора коллекции объектов без раскрытия ее реализации (инкапсуляция механизма перебора элементов разных коллекций объектов)

- КОМПОНОВЩИК (Composite) - клиент получает возможность выполнять однородные операции как с объектами, так и с коллециями этих объектов

- СОСТОЯНИЕ (State) - инкапсулирет поведение, связанное с состоянием, с делегированием поведения объекту текущего состояния

- ЗАМЕСТИТЕЛЬ (Proxy) - упаковывает объект для управления достуом к нему




По остальным паттернам смотрим сюда:
Паттерны проектирования. Э. Гамма, Р. Хелм, Р. Джонсон, Д. Влиссидес, 2010




