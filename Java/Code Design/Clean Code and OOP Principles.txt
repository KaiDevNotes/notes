

Books and sources:

[B1]: Refactoring. Martin Fowler. 2003
[B2]: Refactoring to patterns. Joshua Kerievsky. 2006
[B3]: Clean Code. Robert Martin. 2013


--------------------------------------------------------
--------------------------------------------------------





[+] READABILITY


* На самом деле соотношение времени чтения и написания кода превышает 10:1. Мы постоянно читаем свой 
старый код, поскольку это необходимо для написания нового кода. Упрощение чтения в действительности 
упрощает и написание кода.


* Необходимо постоянно поддерживать чистоту кода путем постоянного РЕФАКТОРИНГа, т.к. некачественный 
код ведет к загниванию кодовой базы, снижению темпов и, в конечном итоге, полной остановке разработки. 


* «Правило бойскаута» гласит: все нужно оставлять чище, чем было до вашего прихода. Не существует модуля, 
который нельзя было бы улучшить, и каждый из нас обязан оставить чужой код хотя бы немного лучше, чем он был.





[+] METHODS


* Первое правило: методы должны быть компактными. Второе правило: методы должны быть еще компактнее.


* МЕТОД ДОЛЖЕН ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ. ОН ДОЛЖЕН ВЫПОЛНЯТЬ ЕЕ ХОРОШО. И НИЧЕГО ДРУГОГО ОН ДЕЛАТЬ НЕ ДОЛЖЕН.
(SRP на уровне методов)


* В конце концов, методы пишутся прежде всего для разложения более крупной концепции (которая выражается 
именем метода) на последовательность действий (шагов) на следующем (более низком) уровне абстракции.


* В идеальном случае количество аргументов метода равно нулю (нуль-арный метод). Далее следуют методы с 
одним аргументом (унарные) и с двумя аргументами (бинарные). Методы с тремя аргументами  (тернарных) 
следует по возможности избегать. Необходимость методов с большим количеством аргументов (полиарных) 
должна быть подкреплена очень вескими доводами — и все равно такие методы лучше не использовать. 
Большое количество аргументов метода могут сигнализировать о нарушении SRP для данного метода.


* Если метод одного объекта должен изменять состояние другого объекта (функциональня зависть), 
то этот метод необходимо перенести в объект, состояние которого он изменяет.
Т.е. если метод f объекта A вызывает только методы объекта B и/или манипулирует состоянием объекта B, то 
метод f должен быть перенесен из объекта A в B (см. B1, p. 154 (Move Method)). 
Это в свою очередь увеличивает внутренюю связность объекта B (High Cohesion) и 
уменьшает внешнюю зависимость объектов A и B друг от друга (Low Coupling).


* Функциональная зависть - это один из «запахов кода», описанных у Мартина Фаулера 
(см. B1, p. 91 (Завистливые функции)). Для методов класса должны быть важны переменные и методы того 
класса, которому они принадлежат, а не переменные и методы других классов. Когда метод использует 
методы доступа другого объекта для манипуляций с его данными, то он завидует области видимости класса 
этого объекта. Он словно мечтает находиться в другом классе, чтобы иметь прямой доступ к переменным, 
с которыми он работает.  


* Либо метод изменяет состояние объекта, либо возвращает информацию об этом объекте, т.е. SRP. 
(см. B1, p. 282 (Separate Query from Modifier))


* Методы должны выполнять одну операцию (SRP). Обработка ошибок — это одна операция. Значит, метод, 
обрабатывающий ошибки, ничего другого делать не должен. Отсюда следует, что если в методе 
присутствует ключевое слово try, то оно должно быть первым словом в метода, а после блоков 
catch/finally ничего другого быть не должно.


* Локальный переменные метода следует объявлять как можно ближе к месту использования.


* Закон Деметры гласит, что метод f класса C должен ограничиваться вызовом методов следующих объектов:
	- C;
 	- объекты, созданные f;
 	- объекты, переданные f в качестве аргумента;
 	- объекты, хранящиеся в переменной экземпляра C.
Метод не должен вызывать методы объектов, возвращаемых любыми из разрешенных методов. Другими 
словами, ВЗАИМОДЕЙСТВОВАТЬ МОЖНО ТОЛЬКО С ДРУЗЬЯМИ, но не с чужаками.


* Если у вас возникает желание вернуть null из метода, рассмотрите возможность выдачи исключения 
или возвращения объекта «особого случая» (см. B1, p. 262 (Introduce Null Object)). 
Если ваш код вызывает метод стороннего API, способный вернуть null, создайте для него обертку в 
виде метода, который инициирует исключение или возвращает объект особого случая.


* Если один метод вызывает другой, то эти методы должны располагаться вблизи друг от друга по 
вертикали, а вызывающий метод должен находиться над вызываемым (если это возможно).


* Не комментируйте плохой код — перепишите его. 


* Вместо комментария необходимо использовать соответствующее имя метода или переменной, чтобы 
код был самодокументирующим.


* Короткие методы не нуждаются в долгих описаниях. Хорошо выбранное имя компактного метода, 
который выполняет одну операцию лучше заголовка с комментарием.





[+] CLASSES


* Система должна состоять из множества мелких классов, а не из небольшого числа больших. Каждый 
класс инкапсулирует одну ответственность (SRP), имеет одну причину для изменения и взаимодействует 
с другими классами для реализации желаемого поведения системы.


* Чем меньше методов содержит класс, тем лучше. Чем меньше переменных экземпляров содержит класс, 
тем лучше. Большое число методов или переменных экземпляра могут сигнализировать о нарушении SRP.


* Класс, в котором каждая переменная используется каждым методом, обладает максимальной внутренней связностью 
(High Cohesion).


* Высокая связность означает, что методы и переменные класса взаимозависимы и существуют как единое целое.





[+] EXCEPTIONS


* Необходимо отказаться от проверяемых исключений. Цена проверяемых исключений — нарушение принципа 
открытости/закрытости (OCP). 
Т.е. при добавлении/изменении/удалении проверяемого исключения, кот. например, пробрасывается по цепочке 
вызовов нам придется ОТКРЫВАТЬ код классов и вносить изменения во все методы, кот. участвуют в данной 
цепочке вызовов.


* Проверяемые исключения иногда могут пригодиться при написании особо важных библиотек: программист 
обязан перехватить их. Но в общем случае разработки приложений проблемы, создаваемые зависимостями, 
перевешивают преимущества.





[+] TDD AND ARCHITECTURE (TESTS, IMPLEMENTATION AND REFACTORING)


* Возможность построить «правильную систему с первого раза» — миф. Вместо этого мы сегодня реализуем 
текущие потребности, а завтра перерабатываем и расширяем систему для реализации новых потребностей. 
В этом заключается суть итеративной, пошаговой, гибкой разработки. Разработка через ТЕСТИРОВАНИЕ, 
РЕФАКТОРИНГ и полученный в результате их применения ЧИСТЫЙ КОД обеспечивают работу этой схемы на уровне кода.


* Важнейшее отличие программных систем от физических в том, что архитектура программных систем может 
развиваться последовательно, если обеспечить правильное разделение ответственности (GRASP).


* Принимая решение в своем коде, убедитесь в том, что вы действуете предельно точно и аккуратно. 
ЗНАЙТЕ, ПОЧЕМУ ПРИНИМАЕТСЯ РЕШЕНИЕ, и как вы собираетесь поступать с исключениями из правила. 
Не ленитесь обеспечивать точность своих решений.


* Независимо от того, проектируете ли вы целую систему или ее отдельные модули, помните: используйте 
САМОЕ ПРОСТОЕ РЕШЕНИЕ из всех возможных. Решение всегда можно изменить путем РЕФАКТОРИНГа при наличии 
набора качественных ТЕСТОВ.


* Архитектура может считаться «простой» и «чистой», если она:
 	- обеспечивает прохождение всех тестов,
	- не содержит дублирующегося кода,
 	- выражает намерения программиста,
 	- использует минимальное количество классов и методов.


* Тестовый код не менее важен, чем код продукта. Не считайте его «кодом второго сорта». К написанию 
тестового кода следует относиться вдумчиво, внимательно и ответственно. Тестовый код должен быть 
таким же чистым, как и код продукта.


* Дублирование — главный враг хорошо спроектированной системы. Его последствия — лишняя работа, лишний 
риск и лишняя избыточная сложность. 
Дублирование возникает как следствие нарушения SRP, т.к. одним из важнейших аспектов хорошей программной 
архитектуры является логическое разбиение кода — создание подходящих мест для размещения разных кодовых 
блоков. Разделение ответственности заметно упрощает понимание и сопровождение кода.


* Каждый раз, когда в программе встречается повторяющийся код, он указывает на упущенную возможность 
для АБСТРАКЦИИ. Возможно, дубликат мог бы стать методом или даже отдельным классом. «Сворачивая» дублирование 
в подобные абстракции, вы расширяете лексикон языка программирования. Другие программисты могут воспользоваться 
созданными вами абстрактными концепциями. Повышение уровня абстракции ускоряет программирование и снижает 
вероятность ошибок.


* Само объектно-ориентированное программирование может рассматриваться как стратегия модульной организации 
кода и устранения дубликатов.





[+] DIFFERENCE BETWEEN OBJECTS AND DATA STRUCTURES (or difference between OOP and FUNCTIONAL paradigms)


* Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными. 
Структуры данных раскрывают свои данные и не имеют осмысленных функций (классический пример, DTO).


* Процедурный код (код, использующий структуры данных) позволяет легко добавлять новые функции без изменения 
существующих структур данных. 
Объектно-ориентированный код, напротив, упрощает добавление новых классов без изменения существующих функций.
Обратные утверждения также истинны.
Процедурный код усложняет добавление новых структур данных, потому что оно требует изменения всех функций. 
Объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.
Таким образом, то, что сложно в ОО, просто в процедурном программировании, а то, что сложно в процедурном 
программировании, просто в ОО.


* Если в некоторой системе нас прежде всего интересует гибкость в добавлении новых типов данных, то в этой 
части системы предпочтение отдается объектной реализации. Но если в других случаях нам нужна гибкость 
расширения поведения, и тогда в этой части используются структуры данных (например, обычный Java Bean, 
т.е. экземпляр класса, кот. содержит свойства, и GETTER'ы и SETTER'ы для них) и процедуры (наример, класс-сервис, 
который может не иметь состояния, но имеет множество методов для манипулирования данными, кот. хранятся в 
структуре данных). И хороший программист относится к этой проблеме без предубеждения и выбирает то решение, 
которое лучше всего подходит для конкретной ситуации.








