

ПОЛИМОРФИЗМ - возможность использовать объекты разных типов, как-будто это объекты одного 
и того же типа. 

Т.е. данные объекты реализуют один и тот же интерфейс или расширяют один 
и тот же родительский класс, и мы можем работать с этими объектами одинаковым образом 
через ссылку, которыя имеет тип реализуемого интерфейса или расширяемого родительского 
класса. 

----------------------------------------------------------------------------------------


Названия объявляемых полей класса, аргументов метода, локальный переменных метода и т.д. д.б. понятными и логичными.

----------------------------------------------------------------------------------------


Каждая новая операция (присвоение, вызов метода и т.п.) должны осуществляться в новой строчке кода.
Таким образом код становится более легким для чтения и DEBUG'a.

----------------------------------------------------------------------------------------


В коде методов не должны использоваться "произвольные" строки или непонятные "конкретные" значения.
Такие значения и строки д.б. оформленых в виде КОНСТАНТ с ПОНЯТНЫМИ ИМЕНАМИ в обявлении класса.
И далее в методах должны использоваться эти КОНСТАНТЫ.

Объявление константы:

[access modifier] static final [type] CONSTANT_NAME = [value];

----------------------------------------------------------------------------------------



Не используй модификатор доступа "по умолчанию". 
Модификатор доступа должен быть указан явно. Чаще всего это "public" или "private".
"protected" используется реже. 
Если "protected" используется часто, то это может сигнализировать о неверной структуре кода.

----------------------------------------------------------------------------------------



Слои приложения д.б. максимально независимыми (изолированными), на сколько это возможно.

Пример: 
-------
В приложении есть web-слой и слой логики.
В параметре http-запроса приходит id платежной карты, кот. необходимо заблокировать.
Для блокировки необходимо использовать метод "block" экземпляра класса логики CardService.
!!! НЕЛЬЗЯ передавать экземпляр httpRequest в метод "block" CardService'a.
!!! Необходимо извлекать id карты в контроллере, кот. обрабатывает запрос и после этого 
передавать его или конкретный экземпляр типа Card в метод "block" CardService'a.
Т.е. web-слой и слой логики д.б. изолтровны друг от друга: web-слой работает с запросами, 
а слой логики с конкретными экземплярами сущностей предметной области (в данном случае экземпляром типа Card)
или их id и выполняет необходимые действия над ними.

----------------------------------------------------------------------------------------



Buidler'ы

Builder - это обычный класс, содержащий нестатический метод "build".
Используем классы-билдеры, когда необходимо создавать и инициализировать 
сущноти предметной области на основе данных полученных из каких-либо источников (xml, JDBC ResultSet и т.д.).

Например, создавать и инициализировать объекты на основе данных, полученных из БД по
средствам JDBC, т.е. из полученного в результате запроса экземпляра ResultSet.

! Хороший пример использования Builder'a как внутренний статический класс, в случае когда мы имеет дело с 
построетием объекта, конструктор которого принимает очень много параметров:
Effective Java. 2nd edition. Joshua Bloch: page 20-21.
Единственное, что в соответствии Java Code Convention мы должны использовать getter'ы и setter'ы в Builder'е 
и в создаваемом им объекте.

----------------------------------------------------------------------------------------



Если необходимо создать иерархию Builder'ов для иерархии классов (классов сущностей предметной области),
необходимо использовать pattern "Template method" (шаблонный метод).

Пример: 
-------
см. иерархию builder'ов для иерархии конфет в проекте "Presents": 
https://github.com/LuiJ/Presents  

----------------------------------------------------------------------------------------



RuntimeException

Для ситуаций, когда мы не ожидаем исключительной ситуации, но она может случиться, 
необходимо использовать подходящий по смыслу предопределнный RuntimeException.

Например, при работе с JDBC необходимо перехватывать SQLException, кот. "на все случаи жизни" и обрабатывать его бесполезно.
В таком случае имеет смысл перехватывать SQLException и выбросить подходящий по смыслу RuntimeException, например IllegalStateException.
Т.е. наше приложениие пришло в состояние, при кот. оно не может продолжить выполнение.
В конструктор IllegalStateException передаем сообщение SQLException'a: IllegalStateException(e.getMessage()).

----------------------------------------------------------------------------------------



В классах сущностей, которые хранятся в БД в качастве типа для поля "id" необходимо выбирать "Integer" вместо приметиа int.

Это рекомендация следует зи того факта, что поля БД без значения имеют значение "NULL", 
т.е. и в сущности в такой ситуации значение поля "id" д.б. "null"

----------------------------------------------------------------------------------------



Если в коде получаются места, кот. "плохо пахнут", но на данный момент не получается найти способ сделать по-другому,
то необходимо в таких местах оставлять КОММЕНТАРИИ с объяснением почему было сделано именно так.

----------------------------------------------------------------------------------------



В ИНТЕРФЕЙСАХ стараться избергать объявления getter'ов и setter'ов.
В ИНТЕРФЕЙСАХ должны храниться бизнес-контракты, т.е. методы в той или иной степени отражающие бизнес-логику.

----------------------------------------------------------------------------------------



Когда необходимо создавать: 
- КЛАСС, кот. ничего не наследует
- дочерний КЛАСС
- АБСТРАКТНЫЙ КЛАСС
- ИНТЕРФЕЙС

См. "Head First. Java" стр. 257

----------------------------------------------------------------------------------------



Для хранения перечислений значений использем только Enum.

----------------------------------------------------------------------------------------



Правила, касающиеся equals и hashCode.

См. "Head First. Java" стр. 593 
(в данном тексте по "идентификатором" подразумевается результат,
возвращаемый методом hashCode)

----------------------------------------------------------------------------------------



Необходимо избегать проверок с последующим вызовом return, break или continue, чтобы не нарушать
прямой поток выполнения кода.
Имеет смысл использовать только return в "сторожевых" проверках, кот. распологаются в начале метода.

----------------------------------------------------------------------------------------


