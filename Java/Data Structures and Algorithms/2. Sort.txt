Data Structures and Algorithms. R. Lefore



Виды сортировки МАССИВОВ:
-------------------------



1. ПУЗЫРЬКОВАЯ сортировка

- Суть: 2.1 Bubble sort.gif

- Сложность: О(N^2) (N в квадрате или квадратичная сложность)

- Реализация в Java:


public void bubbleSort(long[] arr)
{
	int out, in;
	int n = arr.length;
	for (out = n - 1; out > 1; out--)
	{
		for (in=0; in<out; in++)
		{
			if (arr[in] > arr[in+1]) // swap
			{
				long temp = arr[in];
				arr[in] = arr[in + 1];
				arr[in + 1] = temp;
			}
		}
	}
}


--------------------------------------------------------------------------------------



2. Сортировка МЕТОДОМ ВЫБОРА

- Сложность: О(N^2) (N в квадрате или квадратичная сложность)

- Реализация в Java:


public void selectionSort(long[] arr)
{
	int out, in, min;
	int n = arr.length;
	for (out = 0; out < n - 1; out++) 
	{
		min = out; 
		for (in = out + 1; in < n; in++)
		{
			if(arr[in] < arr[min])
			{
				min = in;
			}                 
		}
		// swap
		long temp = arr[out];
		arr[out] = arr[min];
		arr[min] = temp; 
	}
}


--------------------------------------------------------------------------------------



3. Сортировка МЕТОДОМ ВСТАВКИ

- Сложность: О(N^2) (N в квадрате или квадратичная сложность)

- Реализация в Java:


public void insertionSort(long[] arr)
{
	int in, out;
	int n = arr.length;
	for (out = 1; out < n; out++)
	{
		long temp = arr[out];
		in = out;
		while(in > 0 && arr[in - 1] >= temp)
		{
			arr[in] = arr[in - 1];
			--in;
		}
		arr[in] = temp;
	}
}


--------------------------------------------------------------------------------------



4. Сортировка СЛИЯНИЕМ

- Суть: рис. 6.15, 6.16 (р. 271-272)

- Сложность: O(N x log(N))
Это вытекает из того, что для реализации данной сортировки, например, для массива из 8 элементом (N = 8) потребуется 24 операции копирования (см. рис. 6.15 р. 271)
Т.е. 8 x log2(8) = 8 x 3 = 24

- Требует вдвое больше памяти по сравнению с сортируемым массивом; эта ее особенность нередко оказывается серьезным недостатком.

- Реализация в Java: Листинг 6.6 р. 275-278


--------------------------------------------------------------------------------------



5. Сортировка ШЕЛЛА

- Суть: р. 300-303 + 2.5 Shell sort.gif

- Сложность: O(N x (log(N))^2)

- Хорошо подходит для массивов среднего размера — например, до нескольких тысяч элементов. 
Заметно быстрее алгоритмов O(N^2) - таких, как сортировки методом выбора и вставок.

- РЕКОМЕНДУЮТ почти в любой ситуации начинать с сортировки Шелла, а затем переключаться на более сложный алгоритм (такой, как БЫСТРАЯ сортировка) только в том случае, если метод Шелла на практике окажется слишком медленным.

- Формула получения интервальной последовательности: h = h x 3 + 1

- Реализация в Java: Листинг 7.1 р. 305-307


--------------------------------------------------------------------------------------



6. БЫСТРАЯ сортировка

- Основана на механизме РАЗБИЕНИЯ, т.е. на процессе разделения на две группы, при кот. в одну группу входят все элементы со значением ключа выше заданного порога, а в другую — все элементы со значением ключа ниже заданного порога. См. Java-реализацию разбиения в листинге 7.2 р. 311-313

- Суть: р. 325

- Сложность: O(N x log(N))

- В случае, если элементы отсортированы в обратном порядке и в качестве ОПОРНОГО ЗНАЧЕНИЯ для РАЗБИЕНИЯ всегда берется значение последнего элемент массива, то сложность может выродиться до O(N^2).
Чтобы этого избежать необходимо использовать какой-нибудь более оптимальный метод определения ОПОРНОГО ЗНАЧЕНИЯ, например по ТРЕМ ТОЧКАМ (р. 328)


--------------------------------------------------------------------------------------



7. ПОРАЗРЯДНАЯ сортировка

- Суть: р. 339-340

- Сложность: O(N x log(N)), но требует в 2 раза больше памяти, чем быстрая сортировка.








