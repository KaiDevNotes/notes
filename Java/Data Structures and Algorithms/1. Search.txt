Data Structures and Algorithms. R. Lefore



Для МАССИВОВ существует 2 вида поиска:
--------------------------------------


1. ЛИНЕЙНЫЙ поиск

- Суть: Последовательный перебор элементов массива до тех пор пока не будем найден искомый элемент или не будет достигнут конец массива.

- Сложность: O(N)

- Реализация в Java:


public boolean doLinearSearch(long searchKey, long[] arr)
{
	int i;
	int n = arr.length;
	for (i = 0; i < n; i++)
	{
		if (arr[i] == searchKey)
		{
			break;
		}
	}
	if (i == n)
	{
		return false; // Не найден
	}
	else 
	{
		return true; // Найден
	}
}


---------------------------------------------------------------------------------------------


2. ДВОИЧНЫЙ (БИНАРНЫЙ) поиск

- Суть: Последовательное деление диапазона значений на 2 пока диапазон не сузится до скомого значения.

- Применяется только с отсортированной структорой данный (например, отсортиронным массивом)

- Сложность: O(log(N))

- Формула: Количество шагов (сравнений) равно логарифму размера диапазона по основанию 2.

	s = log2(N), s - кол-во шагов для нахождения искомого элемента
				 N - кол-во элементов массива (диапазон значений)

- Обратная формула: 

	N = 2^s ("2" в степени "s")
	
				 
- Реализация в Java:

На основе цикла:

public int doBinarySearch(long searchKey, long[] arrOrdered)
{
	int n = arrOrdered.length;
	int lowerBound = 0;
	int upperBound = n - 1;
	int curIn;
	while(true)
	{
		curIn = (lowerBound + upperBound )/2;
		if(arrOrdered[curIn] == searchKey)
		{
			return curIn; // Если найден: возвращаем позицию элемента
		}            
		else if (lowerBound > upperBound)
		{
			return n; // Если НЕ найден: возвращаем размер массива
		}
		else 
		{
			if(arrOrdered[curIn] < searchKey)
			{
				lowerBound = curIn + 1;
			} 
			else
			{
				upperBound = curIn - 1;
			}
		}
	}
}


На основе рекурсии:

public static int doRecBinarySearch(long searchKey, long[] arrOrdered, 
                                        int lowerBound, int upperBound)
{
	int n = arrOrdered.length;
	int curIn;
	curIn = (lowerBound + upperBound )/2;
	if(arrOrdered[curIn] == searchKey)
	{
		return curIn; // Если найден: возвращаем позицию элемента
	}            
	else if (lowerBound > upperBound)
	{
		return n; // Если НЕ найден: возвращаем размер массива
	}
	else 
	{
		if(arrOrdered[curIn] < searchKey)
		{                    
			lowerBound = curIn + 1;
		} 
		else
		{
			upperBound = curIn - 1;
		}                
		return doRecBinarySearch(searchKey, arrOrdered, lowerBound, upperBound);
	}
}





