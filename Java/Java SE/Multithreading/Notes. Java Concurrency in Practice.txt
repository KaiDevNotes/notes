

Notes regarding book: Java Concurrency in Practice. Brian Goetz. 2006 


---------------------------------------------------------------------




Chapter 2. Thread Safety
--


* Concurrent programming isn't so much about threads or locks. Writing 
thread safe code is, at its core, about managing access to state, and in 
particular to shared, mutable state. 


* If multiple threads access the same mutable state variable without 
appropriate synchronization, your program is broken. 
There are three ways to fix it: 
- Don't share the state variable across threads; 
- Make the state variable immutable; or 
- Use synchronization whenever accessing the state variable.


* When designing thread safe classes, good object oriented techniques 
encapsulation, immutability, and clear specification of invariants are 
your best friends.




2.1. What is Thread Safety?
--


* A  class  is  thread-safe  if  it  behaves  correctly  when  accessed 
from  multiple  threads,  regardless  of  the  scheduling  or interleaving 
of the execution of those threads by the runtime environment, and with no 
additional synchronization or other coordination on the part of the 
calling code. 


* Thread-safe classes encapsulate any needed synchronization so that 
clients need not provide their own.


* Stateless objects are always thread safe.




2.2. Atomicity
--


* Where practical, use existing thread-safe objects, like AtomicLong, 
to manage your class's state. It is simpler to reason about the possible 
states and state transitions for existing thread-safe objects than it is 
for arbitrary state variables, and this makes it easier to maintain and 
verify thread safety. 




2.3. Locking
--


* To preserve state consistency, update related state variables in 
a single atomic operation.


* 2.3.2. Reentrancy (reentrancy description)




2.4. Guarding State with Locks
--


* For each mutable state variable that may be accessed by more than one 
thread, all accesses to that variable must be performed with the same 
lock held. In this case, we say that the variable is guarded by that lock.


* Every shared, mutable variable should be guarded by exactly one lock. 
Make it clear to maintainers which lock that is.


* For every invariant that involves more than one variable, all the 
variables involved in that invariant must be guarded by the same lock.




2.5. Liveness and Performance
--


* The portions of code that are outside the synchronized blocks operate 
exclusively on local (stack-based) variables, which are not shared across 
threads and therefore do not require synchronization.


* Atomic variables are useful for effecting atomic operations on 
a single variable.


* There is frequently a tension between simplicity and performance. 
When implementing a synchronization policy, resist the temptation to 
prematurely sacrifice simplicity (potentially compromising safety) 
for the sake of performance. 


* Avoid  holding  locks  during  lengthy  computations  or  operations 
at risk of not completing quickly such as  network  or console I/O.




Chapter 3. Sharing Objects
--


3.1. Visibility
--


* In order to ensure visibility of memory  writes  across  threads, 
you  must  use synchronization. 


* Locking is not just about mutual exclusion; it is also about memory 
visibility. To ensure that all threads see the most up-to-date values 
of shared mutable variables, the reading and writing threads must 
synchronize on a common lock.


* Use  volatile  variables  only when  they  simplify implementing and 
verifying  your  synchronization  policy; avoid using volatile variables 
when verifying correctness would require subtle reasoning about visibility. 
Good uses of volatile variables  include  ensuring  the  visibility  of  
their  own  state,  that  of  the  object  they  refer  to,  or  indicating  
that an important lifecycle event (such as initialization or shutdown) 
has occurred.


* The  most  common  use  for  volatile  variables  is  as  a completion, 
interruption, or status flag, such as the asleep flag in Listing 3.4.


* Locking can guarantee both visibility and atomicity; 
volatile variables can only guarantee visibility.


* You can use volatile variables only when all the following criteria 
are met: 
- Writes  to  the  variable  do  not  depend  on  its  current  value,  
or you can ensure that only a single thread ever updates the value; 
- The variable does not participate in invariants with other state 
variables; and 
- Locking is not required for any other reason while the variable 
is being accessed.




3.2. Publication and Escape
--


* A common mistake that can let the "this" reference escape during 
construction is to start a thread from a constructor.




3.3. Thread Confinement
--


* Thread-local variables are often used to prevent sharing in designs based 
on mutable Singletons or global variables.


* It is easy to abuse ThreadLocal by treating its thread confinement property 
as a license to use global variables or as a means of creating "hidden" method 
arguments. Like global variables, thread-local variables can detract from 
reusability and introduce hidden couplings among classes, and should therefore 
be used with care.




3.4. Immutability
--


* An immutable object is one whose state cannot be changed after construction.


* Immutable objects are always thread-safe.


* Just as it is a good practice to make all fields private unless they need 
greater visibility [EJ Item 12], it is a good practice to make all fields final 
unless they need to be mutable.




3.5. Safe Publication
--


* Immutable objects can be used safely by any thread without additional 
synchronization, even when synchronization is not used to publish them.


* This guarantee extends to the values of all final fields of properly 
constructed objects; final fields can be safely accessed without additional 
synchronization. However, if final fields refer to mutable objects, 
synchronization is still required to access the state of the objects they 
refer to.


* To publish an object safely, both the reference to the object and the 
object's state must be made visible to other threads at the same time. 
A properly constructed object can be safely published by: 
- Initializing an object reference from a static initializer; 
- Storing a reference to it into a volatile field or AtomicReference; 
- Storing a reference to it into a final field of a properly constructed object; 
- Storing a reference to it into a field that is properly guarded by a lock.

- Placing a key or value in a Hashtable, synchronizedMap, or Concurrent-Map 
safely publishes it to any thread that retrieves it from the Map 
(whether directly or via an iterator); 
- Placing  an  element  in  a  Vector,  CopyOnWriteArrayList,  
CopyOnWrite-ArraySet,  synchronizedList,  or synchronizedSet safely publishes 
it to any thread that retrieves it from the collection; 
- Placing  an  element on a BlockingQueue or a ConcurrentLinkedQueue safely 
publishes  it  to  any  thread  that retrieves it from the queue.


* Safely published effectively immutable objects can be used safely by any 
thread without additional synchronization.


* The publication requirements for an object depend on its mutability:
- Immutable objects can be published through any mechanism; 
- Effectively immutable objects must be safely published; 
- Mutable objects must be safely published, and must be either thread-safe 
or guarded by a lock. 


* The most useful policies for using and sharing objects in a concurrent program 
are: 
- "Thread-confined". A thread-confined object is owned exclusively by and confined 
to one thread, and can be modified by its owning thread. 
- "Shared read-only". A shared read-only object can be accessed concurrently by 
multiple  threads  without  additional synchronization, but cannot be modified  
by any thread. Shared read-only objects include immutable and effectively 
immutable objects. 
- "Shared thread-safe". A thread-safe object performs synchronization internally, 
so  multiple  threads can  freely  access  it through its public interface 
without further synchronization. 
- "Guarded". A guarded object can be accessed only with a specific lock held. 
Guarded objects include those that are encapsulated within other thread-safe 
objects and published objects that are known to be guarded by a specific lock.




Chapter 4. Composing Objects
--


4.1. Designing a Thread-safe Class
--


* While it is possible to write a thread-safe program that stores all its state 
in public static fields, it is a lot harder to verify its thread safety or to 
modify it so that it remains thread-safe than one that uses encapsulation 
appropriately. Encapsulation makes it possible to determine that a class is 
thread-safe without having to examine the entire program.


* The design process for a thread-safe class should include these 3 basic 
elements: 
- Identify the variables that form the object's state; 
- Identify the invariants that constrain the state variables; 
- Establish a policy for managing concurrent access to the object's state.


* Multivariable invariants like this one create atomicity requirements: related 
variables must be fetched or updated in a single atomic operation. 


* You cannot ensure thread safety without understanding an object's invariants 
and postͲconditions. Constraints on the valid values or state transitions for 
state variables can create atomicity and encapsulation requirements.




4.2. Instance Confinement
--


* Encapsulation simplifies making classes thread-safe by promoting instance 
confinement.


* Encapsulating data within an object confines access to the data to the 
object's methods, making it easier to ensure that the data is always accessed 
with the appropriate lock held.


* Confinement makes it easier to build thread-safe classes because a class that 
confines its state can be analyzed for thread safety without having to examine 
the whole program.




4.3. Delegating Thread Safety
--


* If a class is composed of multiple independent thread-safe state variables 
and has no operations that have any invalid state transitions, then it can 
delegate thread safety to the underlying state variables.


* A variable is suitable for being declared volatile only if it does not 
participate in invariants involving other state variables.


* If a state variable is thread-safe, does not participate in any invariants 
that constrain its value, and has no prohibited state transitions for any of 
its operations, then it can safely be published.




4.5. Documenting Synchronization Policies
--


* Document a class's thread safety guarantees for its clients; document its 
synchronization policy for its maintainers.


* Crafting a synchronization policy requires a number of decisions: which 
variables to make volatile, which variables to guard with locks, which lock(s) 
guard which variables, which variables to make immutable or confine to a 
thread, which operations must be atomic, etc.




Chapter 5. Building Blocks
--


5.1. Synchronized Collections
--


* The iterators returned by the synchronized collections are not designed to 
deal with concurrent modification, and they are fail-fast - meaning that if 
they detect that the collection has changed since iteration began, they throw 
the unchecked ConcurrentModificationException.


* An alternative to locking the collection during iteration is to clone the 
collection and iterate the copy instead.


* Just as encapsulating an object's state makes it easier to preserve its 
invariants, encapsulating its synchronization makes it easier to enforce 
its synchronization policy.




5.2. Concurrent Collections
--


* Replacing synchronized collections with concurrent collections can offer 
dramatic scalability improvements with little risk.


* ConcurrentHashMap, along with the other concurrent collections, further 
improve on the synchronized collection classes by providing iterators that 
do not throw ConcurrentModificationException, thus eliminating the need to 
lock the collection during iteration.


* Because it has so many advantages and so few disadvantages compared to 
Hashtable or synchronizedMap, replacing synchronized Map implementations with 
ConcurrentHashMap in most cases results only in better scalability. Only if your
application needs to lock the map for exclusive access (Or if you are relying 
on the synchronization side effects of the synchronized Map implementations.) 
then ConcurrentHashMap is not an appropriate drop-in replacement. 


* The iterators returned by the copy-on-write collections do not throw 
ConcurrentModificationException and return the elements exactly as they were 
at the time the iterator was created, regardless of subsequent modifications.


* The copy-on-write collections are reasonable to use only when iteration is 
far more common than modification. 




5.3. Blocking Queues and the Producer-Consumer Pattern
--


* Bounded queues are a powerful resource management tool for building reliable 
applications: they make your program more robust to overload by throttling 
activities that threaten to produce more work than can be handled.


* The last BlockingQueue implementation, SynchronousQueue, is not really a 
queue at all, in that it maintains no storage space for queued elements. 
Instead, it maintains a list of queued threads waiting to enqueue or dequeue 
an element. In the dish-washing analogy, this would be like having no dish 
rack, but instead handing the washed dishes directly to the next available 
dryer. While this may seem a strange way to implement a queue, it reduces 
the latency associated with moving data from producer to consumer because 
the work can be handed off directly. (In a traditional queue, the enqueue and 
dequeue operations must complete sequentially before a unit of work can be 
handed off.) The direct handoff also feeds back more information about the 
state of the task to the producer; when the handoff is accepted, it knows a 
consumer has taken responsibility for it, rather than simply letting it sit on 
a queue somewhere - much like the difference between handing a document to a 
colleague and merely putting it in her mailbox and hoping she gets it soon.
Since a SynchronousQueue has no storage capacity, put and take will block 
unless another thread is already waiting to participate in the handoff. 
Synchronous queues are generally suitable only when there are enough consumers 
that there nearly always will be one ready to take the handoff.


* Many producer-consumer designs can be expressed using the Executor task 
execution framework, which itself uses the producer-consumer pattern.


* A producer-consumer design has one shared work queue for all consumers; 
in a work stealing design, every consumer has its own deque. If a consumer 
exhausts the work in its own deque, it can steal work from the tail of someone 
else's deque.




5.4. Blocking and Interruptible Methods
--


* When a method can throw InterruptedException, it is telling you that it is 
a blocking method.


* When your code calls a method that throws InterruptedException, then your 
method is a blocking method too, and must have a plan for responding to 
interruption.




5.5. Synchronizers
--


>>> p. 76














































