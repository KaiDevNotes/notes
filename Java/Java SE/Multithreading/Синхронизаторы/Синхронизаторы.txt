[Java 8. Полное руководство. Г. Шилдт]


Semaphore (стр. 1008)

Используется для ограничения доступа к некоторому общему ресурсу.
При создании СЕМАФОРА задается кол-во разрешений, т.е. кол-во потоков, которые одновременно могут пользоваться общим ресурсом.
Если счетчик разрешений больше нуля, то СЕМАФОР разрешает потоку доступ к ресурсу.
А если равен нулю - отказывает потоку в доступе, данный поток приостанавливается и ожидает разрешения.
Когда поток получает разрешение на доступ к ресурсу - счетчик разрешений СЕМАФОРА уменьшается на единицу.
Когда поток освобождает разрешение - счетчик разрешений СЕМАФОРА увеличивается на единицу.


--------------------------------------

CountDownLatch (стр. 1014)

Использется для САМОБЛОКИРОВКИ потока до наступления определенного количества событий.
Количество событий задается в процессе создания объекта типа CountDownLatch. Наступление каждого события уменьшает счетчик событий на единицу.
Т.е. поток приостанавливает свое выполнение, ожидает наступления необходимого количества событий и далее продолжает свое выполнение.
Грубо говоря получаем "самоблокировку потока с обратным отсчетом".


--------------------------------------

CyclicBarrier (стр. 1016)

CyclicBarrier определяет БАРЬРНУЮ точку или БАРЬЕР.
Используется, когда необходимо приостановить один или несколько потоков в определенной точке, чтобы они ожидали пока остальные потоки не достигнут этой точки.
Количество потоков, которые должны ожидать в определнной барьером точке, указывается при создании экземпляра CyclicBarrier.
Этот процесс реализуется следующим образом:
- экземпляра CyclicBarrier передается всем экземпляра потоков, которые должны ожидать в указанной точке
- когда один из этих потоков достигает в процессе своего выполнения барьерной точки, он вызывает метод await(), тем самым приостанавливается его выполнение пока необходимое число потоков не достигнет барьерной точки, т.е. пока из них не будет вызван метод await()
- когда в потоке вызывается метод await() счетчик в экземпляре CyclicBarrier уменьшается на единицу.
- когда значение счетчика становится равным нулю, все потоки, ожидающие в данной барьерной точке


--------------------------------------

Exchanger (стр. 1018)

Используется, когда необходимо синхронизировать обмен данными между двумя потоками.
Принцип действия:
- создается экземпляр обобщенного класса Exchanger<V>, в кот. вместо V передается тип данных, которыми обмениватся потоки
- это экземпляр типа Exchanger передается двум потокам
- когда в одном потоке вызывается метод exchange (через, кот. передаются дааные между потоками), этот поток приостанавливается и ожидает пока метод exchange не будет вызван во втором потоке
- когда метод exchange вызывается во втором потоке, Exchanger осуществляет обмен данными между этими двумя потоками и далее они продолжают свое выполнение


--------------------------------------

Phaser (стр. 1020)

Phaser - это синхронизатор фаз процесса.
Применяется как CyclicBarrier для синхронизации различных фаз выполнения общего процесса и составляющих его потоков (сторон).

Например (см. пример стр. 1022):
Имеется процесс, состоящий из 3 фаз. В этом процессе участвует 3 потока (т.е. зарегистрировано 3 стороны). Каждый поток также делится на 3 фазы.
Чтобы первая фаза процесса считалась выполненной необходимо, чтобы выполнилась первая фаза в каждом потоке, который зарегистрирован в процессе как строна.
Когда в одном из потоков выполняется первая фаза он вызывает метод arriveAndAwaitAdvance() экземпляра типа Phaser. Это приводит к приостановки выполнения данного потока и он ожидает пока первая фаза не будет завершена в остальных зарегистрированных потоках, т.е. пока в них не будет вызван метод arriveAndAwaitAdvance().
Когда это произойдет процесс перейдет на вторую фазу и потоки продолжат свое выполнение, т.е. каждый поток будет выполнять свою вторую фазу, после ее выполнения вызовет метод arriveAndAwaitAdvance() и приостановится в ожидании остальных сторон. И т.д... пока не будут выполнены все 3 фазы процесса.

!!! Сколько фаз в ПРОЦЕССЕ, столько фаз и в каждом, составляющем процесс, потоке (стороне процесса), т.е. столько раз должен быть вызван метод arriveAndAwaitAdvance() в каждом потоке, зарегистрированном в ПРОЦЕССЕ.




