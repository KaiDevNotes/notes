Продемонстрируем взаимодействие КЛИЕНТА и СЕРВЕРА в сеть, реализованных с помощью библиотеки java.net на основе сокетов.
Для этого создадим 2 Java-проекта Client и Server. 
---------------------------------------------------------------------------------------

1) Реализуем СЕРВЕР. Он реализуется на основе типа ServerSocket. В конструкторе указывается номер порта, кот. будет прослушивать наш сервер.

1.1 - Для того чтобы сервер не выключался после первого обработанного запроса организуем бесконечный цикл while(true){...}.

1.2 - Метод accept() активирует сервер для прослушивания указанного порта и блокирует поток выполнения программы до тех пор, пока клиент не установит соединение на прослушиваемый сервером порт. Когда клиент устанавливает соединие, данный метод возвращает экземпляр типа Socket данного соединения.

1.3 - Из экземпляра типа Socket получает потоки ввода и вывода.

1.4 - Принимаем массив байт запроса из потока ввода и формируем из него строку.

1.5 - Если полученная строка запроса равна "REQUEST", то сервер отвечает строкой "RESPONSE". В противном случае сервер отвечает строкой "BAD REQUEST".

1.6 - Строка ответа сервера преобразуется в массив байт и передается клиенту через поток вывода.

1.7 - Далее все заново --> 1.2


Проект Server ---> main.Server.java
------------------------------------

package main;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;


public class Server {
    
    public static void main(String[] args) throws IOException {
        
        // Создаем сокет-сервер, кот. слушает заданный порт 8300 на localhost'e
        ServerSocket server = new ServerSocket(8300);
        // -----
        System.out.println("(1) Server listening port 8300...");
        // Активируем сервер для прослушивания указанного порта
        while (true){
            // Метод accept() блокирует поток выполнения программы до тех пор, 
            // пока клиент не установит соединение на прослушиваемый сервером порт.
            Socket s = server.accept();
            System.out.println("(3) Client has connected");
            // Получаем потоки ввода и вывода
            InputStream is = s.getInputStream();
            OutputStream os = s.getOutputStream();
            // Принимаем сроку запроса
            byte[] requestBytes = new byte[7];
            is.read(requestBytes);
            String requestString = new String(requestBytes, 0, 7);
            // ------
            System.out.println("(6) Client request ---> "+requestString);
            // ------
            String responseString = "";
            // Если строка запроса равна REQUEST, от отвечаем строкой RESPONSE
            if (requestString.equals("REQUEST")){                
                responseString = "RESPONSE";                
            }
            // В противном случае BAD REQUEST
            else {
                responseString = "BAD REQUEST";   
            }
            byte[] responseBytes = responseString.getBytes();
            os.write(responseBytes);
            // ------
            System.out.println("(7) Server send response ---> "+responseString);
            System.out.println();
        }        
        
    }
    
}



---------------------------------------------------------------------------------------


2) Реализуем КЛИЕНТ. Он реализуется на основе типа Socket.

2.1 - Для установления соединения с сервером необходимо создать экземпляр типа Socket. 
В конструктор передается эземпляр типа InetAddress и номер порта (в данном случае 8300, т.к. сервер слушает на нем). 
Эземпляр типа InetAddress создается для localhost, т.к. КЛИЕНТ и СЕРВЕР работают на localhost'e. 
Если сервер работает на другом хост, то необходимо в методе getByName указать имя этого хоста или ip-адрес. 

2.2 - Из экземпляра типа Socket получает потоки ввода и вывода.

2.3 - Преобразуем строку запроса "REQUEST" в массив байт и передаем его серверу через поток вывода.

2.4 - Ждем ответа сервера в бесконечном цикле while(true){...}.

2.5 - Когда приходит ответ от сервера, т.е. количество доступных байт ответа НЕ РАВНО нулю, байты ответа сервера читаются из потока ввода в массив байт. Далее этот массив байт преобразуется в строку и выводится в консоль.


Проект Client ---> main.Client.java
------------------------------------

package main;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;


public class Client {

    public static void main(String[] args) throws UnknownHostException, IOException {
        
        // Клиент и сервер находятся на одном хосте, т.е. на localhost'e
        InetAddress a = InetAddress.getByName("localhost");
        // -----
        System.out.println("(2) Client try to connect to the server...");
        // Устанавливаем соединение с сервером, кот. слушает 8300 порт на localhost'e
        Socket s = new Socket(a, 8300);
        // -----
        System.out.println("(4) Client has connected to the server");
        // Получаем потоки ввода и вывода
        InputStream is = s.getInputStream();
        OutputStream os = s.getOutputStream();
        // Отправляем на сервер запрос: строка REQUEST, преобразованная в байты
        String requestString = "REQUEST";
        byte[] requestBytes = requestString.getBytes();
        os.write(requestBytes);
        // -----
        System.out.println("(5) Client send request ---> "+requestString);
        // Ждем ответ от сервера
        while (true){
            // Получаем кол-во доступных байт ответа
            int c = is.available();            
            // Дождались
            if (c != 0){
                // Получаем байты ответа
                byte[] responseBytes = new byte[c];
                is.read(responseBytes);
                // Выводим ответ сервера в консоль преобразуя массив байтов ответа с строку.                
                String responseString = new String(responseBytes, 0, c);
                System.out.println("(8) Server response ---> "+responseString);
                System.out.println();
                break;
            }
        }
        
    }
    
}

---------------------------------------------------------------------------------------

3) ЗАПУСК ПРИМЕРА:

Запускаем сначало сервер, а затем клиента. В результате получаем следующие выводы для каждого проекта.
В выводы запуска проектов добавлены номера шагов (n) взаимодействия между клиентом и сервером):

3.1 - Если клиент шлет строку запроса "REQUEST"

СЕРВЕР:
-------
(1) Server listening port 8300...
(3) Client has connected
(6) Client request ---> REQUEST
(7) Server send response ---> RESPONSE

КЛИЕНТ:
-------
(2) Client try to connect to the server...
(4) Client has connected to the server
(5) Client send request ---> REQUEST
(8) Server response ---> RESPONSE


3.1 - Если клиент шлет строку запроса отличную от "REQUEST", например "BAD"

СЕРВЕР:
-------
(1) Server listening port 8300...
(3) Client has connected
(6) Client request ---> BAD
(7) Server send response ---> BAD REQUEST

КЛИЕНТ:
-------
(2) Client try to connect to the server...
(4) Client has connected to the server
(5) Client send request ---> BAD
(8) Server response ---> BAD REQUEST



