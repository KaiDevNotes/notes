Java 8. Полное руководство. Г. Шилдт.pdf --- Глава 18.

https://habrahabr.ru/post/162017/


-------------------------------------------------------------------------------------------

COLLECTION

interface Collection<E>

Служит основанием, на котором построен весь каркас коллекций, поскольку он должен быть реализован всеми классами коллекций. 

Расширяет интерфейс Iterable, что позволяет перебирать все коллекции, организовав цикл FOR в стиле FOREACH.




-------------------------------------------------------------------------------------------

LIST

interface List<E>

Расширяет интерфейс Collection.
Определяет такое поведение коллекций, которое сохраняет последовательность элементов. Элементы могут быть введены или извлечены по индексу их позиции в списке, начиная с нуля.
Список может содержать повторяющиеся элементы.

---------------------

class ArrayList<E>

Расширяет класс AbstractList и реализует интерфейс List.
Поддерживаются динамические массивы, которые мoгут наращиваться по мере надобности. Стандартные массивы в Java имеют фиксированную длину.

https://habrahabr.ru/post/128269/

ArrayList в 90% случаев предпочтительнее, чем LinkedList по потребляемой памяти и скорости выполнения операций, т.е. если нет интенсивной работы с серединой списка (вставка/удаление).

+ возможность доступа к произвольному элементу по индексу за постоянное время O(1), т.к. в основе лежит массив.
+ если нет необходимости расширять массив, то вставка в конец производится за постоянное время O(1).
+ позволяет хранить любые значения в том числе и null.

- contains выполняется за линейное время O(n). 
- вставка/удаление элемента в середине списка взывает перезапись всех элементов размещенных «правее» в списке на одну позицию вправо/влево.
- при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize(). 



class LinkedList<E>

Расширяет классы AbstractList, AbstractSequentalList и реализует интерфейсы List, Queue, Deque. 
Предоставляет структуру данных связного двунаправленного списка, где каждый элемент структуры содержит указатели на предыдущий и следующий элементы.

https://habrahabr.ru/post/127864/

Из LinkedList можно организовать стэк, очередь, или двойную очередь, с постоянным временем доступа O(1);

Предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.
Доступ к произвольному элементу осуществляется за линейное время O(n), но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1) (ссылки постоянно хранятся на первый и последний).

+ позволяет хранить любые значения в том числе и null
+ итератор поддерживает обход в обе стороны




-------------------------------------------------------------------------------------------

SET

interface Set<E>

Расширяет интерфейс Collection.
Определяет множество, т.е. поведение коллекций, не допускающих дублирования элементов.



interface SortedSet<E>

Расширяет интерфейс Set и определяет поведение множеств, отсортированных в порядке возрастания.



interface NavigableSet<E>

Расширяет интерфейс SortedSet и определяет поведение коллекции, извлечение элементов из которой осуществляется на основании наиболее точного совпадения с заданным значением или несколькими значениями.

----------------------

class HashSet<E>

Служит для создания коллекции, для хранения элементов которой используется хеш-таблица. Где элемент сохраняется по индексу, который вычисляется как хеш ключа, которым является сам элемент.
За счет хеширования обеспечивается постоянство времени выполнения методов add(), contains(), remove() и size() даже для крупных множеств.
Не гарантирует упорядоченности элементов, поскольку процесс хеширования сам по себе обычно не приводит к созданию отсортированных множеств. Если необх. сортировка, то используют TreeSet



class LinkedHashSet<E>

Определяет связный список элементов хеш-множества в том порядке, в каком они введены в него. Следовательно, когда перебор элементов хеш-множества типа LinkedHashSet производится с помощью итератора, элементы извлекаются из этого множества в том порядке, в каком они были введены.



class TreeSet<E>

Расширяет класс AbstractSet и реализует интерфейс NavigableSet. 
Cоздает коллекцию, где для хранения элементов применяет древовидная структура. 
Объекты сохраняются в отсортированном порядке по нарастающей.

+ время доступа и извлечения элементов достаточно мало, благодаря чему класс TreeSet оказывается отличным выбором для хранения больших объемов отсортированных данных, которые должны быть быстро найдены.
+ применение компораторов для сортировки.




-------------------------------------------------------------------------------------------

QUEUE

interface Queue<E>

Расширяет интерфейс Collection.
Определяет поведение очереди, которая действует как с писок по принципу "первым вошел - первым обслужен". Тем не менее имеются разные виды очередей, порядок организации в которых основывается на некотором критерии. 
В реализациях не допускаются пустые элементы.



interface Deque<E>

Расширяет интерфейс Queue и определяет поведение двусторонней очереди, которая может функционировать как стандартная ОЧЕРЕДЬ по принципу FIFO "первым вошел - первым обслужен" или как СТЕК по принципу LIFO "последним вошел - первым обслужен".

----------------------

class PriorityQueue<E>

Расширяет клacc AbstractQueue и реализует интерфейс Queue. Он служит для создания очереди по приоритетам на основании компаратора очереди.



class ArrayDeque<E>

Расширяет класс AbstractCollection и реализует интерфейс Deque. 
Класс ArrayDeque содержит динамический массив, неимеющий ограничений по емкости.




-------------------------------------------------------------------------------------------

MAP

interface Мар<К,V>

Отображает ключи на значения, т.е. определяет способ хранения пар ключ - значение.



interface SortedМap<K,V>

Расширяет интерфейс Мар. Он обеспечивает размещение записей в отображении по порядку нарастания ключей.

+ обеспечивают очень эффективное манипулирование подотпображениями (подмножествами отображений).



interface NavigableМap<K,V>

Расширяет интерфейс SortedМap и определяет поведение отображения, поддерживающего извлечение записей по наиболее точному совпадению с заданным ключем или несколькими ключами.



interface Мap.Entry<K,V>

Позволяет обращаться с отдельными записями в отображении.

------------------------

class HashМap<K,V>

Расширяет класс AbstractMap и реализует интерфейс Мар.
В нем используется хеш-таблица для хранения отображений.

https://habrahabr.ru/post/128017/

Следует иметь в виду, что хеш-отображение не гарантирует порядок расположения своих элементов. Следовательно, порядок, в котором элементы вводятся в хеш-отображение, не обязательно соответствует тому порядку, в котором они извлекаются итератором.

+ обеспечивается постоянное время выполнения методов get() и put() даже в обращении к крупным отображениям.



class IdentityHashМap<K,V>

Расширяет класс AbstractMap и реализует интерфейс Мар. Он аналогичен классу HashMap, за исключением того, что при сравнении элементов отображения в нем выполняется проверка ссылок на равенство.



class LinkedНashМap<K,V>

Создает связный список элементов, располагаемых в отображении в том порядке, в котором они вводились в него. Это позволяет организовать итерацию с вводом элементов в отображение в определенном порядке.



class ТrееМар<К,V>

Расширяет класс AbstractMap и реализует интерфейс NavigableMap.
Создается отображение, размещаемое в древовидной структуре.

+ эффективные средства для хранения пар ключ-значение, отсортированных в порядке нарастания ключей.
+ быстрое извлечение пар ключ-значение.
+ Применение компораторов для сортировки пар ключ-значение.



class EnumМap<K extends Enum<К>, V>

Расширяет класс AbstractMap и реализует интерфейс Мар. 
Предназначен для применения вместе с ключами типа enum.

----------------------------------------------------------------------------------------------





УНАСЛЕДОВАННЫЕ КЛАССЫ И ИНТЕРФЕЙСЫ:
------------------------------------

!!! Все унаследованные коллекции явл. синхронизированныйми.



class Vector

Реализует динамический массив. Подобен классу ArrayList, но является синхронизированным.
В новом каркасе коллекций реализует интерфейс List и расширяет AbstractList.
Помимо методов определенных в интерфейсе List имеет собственные методы (стр. 636)



class Stack

Является производным от класса Vector и реализует стандартный стек (LIFO).



abstract class Dictionary

Действует анналогично интерфейсу Map.



class Hashtable 

Является конкретной реализацией Dictionary.
Подобна коллекции HashMap, но ни ключи, ни значения не могут быть пустыми и Hashtable явл. синхронизированной коллекцией.



class Properties

Явл. производным от класса Hashtable. Ключи и значения имеют тип String.

+ поддерживает значения по умолчанию
+ поддерживает методы store() и load(), кот. позволяют сохранять данные на диск и загружать данные с диска.








