[Java 8. Полное руководство. Г. Шилдт]



Каркас Fork/Join Framework используется для реализации стратегии "РАЗДКЛЯЙ И ВЛАСТВУЙ", т.е. эффективного использования многопроцессорных многоядерных систем.

------------------------------

Стратегия "РАЗДКЛЯЙ И ВЛАСТВУЙ" (стр. 1045):

Стартегия подразумевает рекурсивное разделение задачи на подзадачи до тех пор, пока объем каждой отдельной подзадачи не станет достаточно мелким для последовательной обработки каждой подзадачи в рамках решения общей задачи.
(Рекурсивное разделение задачи значит, что задача делится на 2 подзадачи. Далее каждая подзадача делится еще на 2 подзадачи и т.д.)

Отсюда вытекае приемущество данной стратегии, т.к. многие подзадачи могут выполняться параллельно в много процессорных системах.
Т.е. каркас Fork/Join Framework позволяет разделить задачу, состоящую из однотипных оперераций (например, вычисление корня каждого члена БОЛЬШОГО массива чисел), на подзадачи и выполнять эти подзадачи параллельно (см. пример, стр. 1047).

Процесс рекурсивное разделение задачи должен продолжаться до тех пор, пока не будет достигнуто ПОРОГОВОЕ ЗНАЧЕНИЕ, при котором последовательное рашение задачи оказывается быстрее, чем дальнейшее ее разделение на подзадачи.  

Оптимальное ПОРОГОВОЕ ЗНАЧЕНИЕ лежит в промежутке между 100 - 10000 этапов вычисления (эмпирически выведено автором книги).
Если этапы вычислений достаточно продолжителен, то необходимо выбирать малые ПОРОГОВЫЕ ЗНАЧЕНИЯ. И напротив, если каждый этап вычислений очень короткий, то высокое ПОРОГОВОЕ ЗНАЧЕНИЕ может обеспечить лучший результат.

------------------------------

Основные компоненты каркаса Fork/Join Framework:

ForkJoinPool - пул потоков для выполнения задач типа ForkJoinTask (похож Executor для потоков-задач типа Callable).
При создании экземпляра ForkJoinPool можно задавать УРОВЕНЬ ПАРАЛЛЕЛИЗМА - это int, кот. по идее задает кол-во одновременно выполняемых подзадач, но не факт, т.к. это еще зависит от того, какую процессорную мощность использует JVM и сам ForkJoinPool. 
УРОВЕНЬ ПАРАЛЛЕЛИЗМА должен быть больше нуля, но меньше ПОРОГОВОГО ЗНАЧЕНИЯ. 
Оптимальные величины УРОВНЯ ПАРАЛЛЕЛИЗМА и ПОРОГОВОГО ЗНАЧЕНИЯ можно замерив разность между временной отсечкой после и до выполнения задачи с помощью System.nanoTime(), кот. возвращает временной штамп в нано секундах.

ForkJoinTask<V> - абстракция выполняемой задачи.

RecursiveAction - класс, производный от ForkJoinTask, который представляет собой задачу, в результате выполнения которой НЕ ВОЗВРАЩАЕТСЯ результат ее выполнения.
Пример исспользования см. стр. 1047, 1050.

RecursiveTask<V> - класс, производный от ForkJoinTask, который представляет собой задачу, в результате выполнения которой ВОЗВРАЩАЕТСЯ результат ее выполнения (похож на поток-задачу типа Callable).
Пример исспользования см. стр. 1053.

------------------------------

