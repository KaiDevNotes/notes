[Java 8. Полное руководство. Г. Шилдт. 9 издание 2015 год]

--------------------------------------------------------------------


ОБОБЩЕНИЯ
-----------
(поддерживаются c версии JDK 5) 
 

1) Обобщения позволяют создавать "параметризованные" ИНТЕРФЕЙСЫ, КЛАССЫ и МЕТОДЫ реализующие функционал который можно применять к различным типам данных.

Например, функционал СТЕКа будет общим (одинаковым) для всех типов данных, которые могут в нем храниться. Collections Framework также реализован на основе обощений.

Параметризованные - это значит, что при объявлении, например, класса ему, в качестве параметра типа T, передается тип объекта (данных), который будет хратинь экземпляр этого обощенного класса.

Простой пример обощенного КЛАССА стр. 396


2) Обобщения работают только со ссылочными типами.
Т.е. при соднании экземпляра обощенного типа нельзя использовать примитивные типы в качестве параметра типа.


3) Обобщения обеспечивают типовую безопасность.

Обощения можно иммитировать используя тип Object базовый для всех типов (см. пример стр. 401). 
Но в этом случает возникают следующие недостатки:
- компилятор не знает ничего об истенном типе хранимого объекта в экземпляре обощенного типа
- необходимость явного приведения тапов при получении объекта из экземпляра обобщенного типа, что может приводить к ошибкам

Использование обощений позволяет достич следующих приемуществ:
- компилятор получает информацию о типе хранимого объекта в экземпляре обощенного типа
- выполняется автоупаковка/автораспаковка
- приведение типов выполняется автоматически 
- ошибки возникающие во время выполнения (возникают при использовании "псквдообощений" через Object) переобразуются в ошибки, обнаруживаемые во время компиляции (благодаря обощениям)


4) Механизм обощений позволяет ограничевать типы, которые можно передавать обощенному ИНТЕРФЕЙСУ, КЛАССУ или МЕТОДУ (стр. 405-406, пример стр. 406)


5) Типовые параметры необходимые для объявления обощенного суперкласса должны передваться всем подклассам (классам наследникам). (см. пример стр. 422-423)


6) Суперклассом для обобщенного класса может выступать как обощенный так и необощенный класс. (см. пример стр. 424-425)


7) Обощение МЕТОДА (см. пример стр. 414).
- обобщенный метод можно объявлять как в обобщенном, так и в необощенном классе
- обощенный метод может быть как статическим, так и динамическим
- обощенный метод можно переопределять в классе наследнике как и обычный метод 


8) Обощение КОНСТРУКТОРА (см. пример стр. 417).
- обобщенный конструктор можно объявлять как в обобщенном, так и в необощенном классе


9) Обощение ИНТЕРФЕЙСА (см. пример стр. 417-418).
- класс реализующий обощенный нтерфейс также долже быть обощенным
- если класс реализуем конкретный тип обощенного интерфейса (например: interface IGen<Integer>), то реализующий класс не обзан быть обощенным


10) Нельзя получить экземпляр типа, хранимого в параметре типа T, т.е. нельзя внутри обощенного класса сделать вот, так: T obj = new T();
Таким же образом нельзя создавать массив: T[] a = new T[10];


11) Нельзя внутри обобщенного класса объявлять статические члены (поля, методы), которые имеют тип Т.


12) Обощенный класс не может расширять класс Throwable, т.е. нельзя создавать обощенные классы исключений. 





 