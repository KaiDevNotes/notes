

Books and sources:

[B1]: Refactoring. Martin Fowler. 2003
[B2]: Refactoring to patterns. Joshua Kerievsky. 2006
[B3]: Clean Code. Robert Martin. 2013


--------------------------------------------------------
--------------------------------------------------------





[+] Концепции ООП:

	- Абстракция (SOLID: DIP)
	- Инкапсуляция 
	- Полиморфизм (SOLID: LSP)
	- Наследование


* Одним из главных принципов объектно-ориентированного программирования является ИНКАПСУЛЯЦИЯ, или сокрытие 
данных. Она гласит, что данные никогда не должны быть открытыми. Если сделать данные открытыми, другие объекты 
смогут читать и изменять их значения без ведома объекта-владельца этих данных. 
Тем самым данные отделяются от поведения. Но весь смысл объектов в том, что они позволяют ИНКАПСУЛИРОВАТЬ и 
хранить данные вместе с процедурами их обработки.
Фундаментальное практическое правило гласит: то, что изменяется одновременно, надо ИНКАПСУЛИРОВАТЬ и хранить 
в одном месте. Данные и методы, использующие эти данные, обычно изменяются вместе.


* ПОЛИМОРФИЗМ - это возможность использовать объекты разных типов, как-будто это объекты одного и того же типа. 
Т.е. объекты реализуют один и тот же интерфейс или расширяют один и тот же родительский класс, и мы можем 
работать с этими объектами одинаковым образом через ссылку, которыя имеет тип реализуемого интерфейса или 
расширяемого родительского класса, т.е. вызывать открытые методы, кот. объявлены в реализуемом интерфейсе 
или расширяемом родительском классе.


* Сущность ПОЛИМОРФИЗМА состоит в том, что он позволяет избежать написания явных условных операторов, 
когда есть объекты, поведение которых различно в зависимости от их типа.






[+] Базовые принципы ООП:

	- Инкапсулируйте то, что изменяется (ИНКАПСУЛЯЦИЯ)
	- Предпочитайте композицию наследованию (ДЕЛЕГИРОВАНИЕ)
	- Программируйте на уровне интерфейсов (АБСТРАКЦИЯ)
	- Код должен зависеть от абстракции (интерфейс, абстр. класс), а не от конкретных классов
	- Стремитесь к слабой связности взаимодействующих обектов (SOLID: DIP) 
	- Классы должны быть открытыми для расширения, но закрытыми для изменения (SOLID: OCP)
	- Взаимодействуйте только с "друзьями" (Закон Деметры)
	- Метод/Класс/Модуль/Пакет должен иметь только одну обязанность (причину для изменения) (SOLID: SRP)






[+] SOLID (SRP, OCP, LSP, ISP, DIP)


* (SRP) Single responsibility principle - метод/класс/пакет/модуль должен иметь одну 
обязанность/ответственность (одну причину для изменения).

* (OCP) Open/closed principle - говорит о том, что програмные сущности должны быть открыты для расширения, 
но закрыты для изменений.
- открыты для расширения: означает, что поведение сущности может быть расширено, путём создания новых 
подтипов сущностей.
- закрыты для изменения: в результате расширения поведения сущности, не должны вносится изменения в код, 
которые эти сущности используют.

* (LSP) Liskov substitution principle - принцип подстановки Барбары Лисков, который говорит, что функция, 
использующая базовый тип, должна иметь возможность использовать подтипы базового типа, не зная об этом.
Иными словами речь идет о ПОЛИМОРФИЗМе

* (ISP) Interface segregation princilpe - говорит о том, что лучше иметь множество узкоспециализированых 
интерфейсов, чем один универсальный.

* (DIP) Dependency inversion principle - говорит о том, что зависимости в системе должны строиться на 
основе абстракций. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие 
должны зависеть от абстракций. В свою очередь, абстракции не должны зависеть от деталей. 
Детали должны зависить от абстракций.



* SRP, High Cohesion, Low Coupling. Эти 3 принципа тесно связаны и выполнение одного принципа является 
следствием выполнения 2ух других: 

* SRP (Single Responsibility Principle) - метод/класс/пакет/модуль должен иметь одну 
обязанность/ответственность (одну причину для изменения).

* High Cohesion (высокое внутренняя связность) - если SRP выполняется на уровне класса/пакета/модуля, 
то это приводит к тому, что все связанные данные и обязанности распологаются в одном месте (классе/пакете/модуле).

* Low Coupling (низкая внешняя зависимость) - если все связанные данные и обязанности распологаются в 
одном месте (классе/пакете/модуле), то это приводит к снижению количества внешних зависимостей с другими 
классами/модулями. Т.е. все необходимое для реализации определенных обязанностей (функционала) находится 
в одном месте. 






[+] GRASP


* GRASP (General Responsibility Assignment Software Patterns)- это паттерны (принципы) распределения 
обязанностей между объектами системы:

	- Information Expert (Информационный эксперт)  
	- Creator (Создатель) 
	- Controller (Контроллер) 
	- Low Coupling (Слабая связанность) 
	- High Cohesion (Сильное зацепление) 
	- Polymorphism (Полиморфизм) 
	- Pure Fabrication (Чистая выдумка) 
	- Indirection (Посредник) 
	- Protected Variations (Сокрытие реализации)


* Information Expert 
Обязанности должны быть назначены объекту, который владеет максимумом необходимой информации для 
выполнения обязанности (информационному эксперту).


* Creator - это применение шаблона Information Expert к проблеме создания объектов.
Класс B должен (может) создавать объекты класса A если:
	- Класс B содержит или агрегирует объекты A.
	- Класс B записывает экземпляры объектов A.
	- Класс B активно использует объекты A
	- Класс B обладает данными инициализации для объектов A.
Объекты-фабрики так же имеют ответственность "создатель" (Creator).


* Controller берет на себя ответственность за выполнение операций, приходящих от пользователя. 
Как правило, не выполняет работу самостоятельно, а делегирует обязанности компетентным объектам.
Пример: Model-View-Controller


* Low Coupling распределяет обязанности междуобъектами таким образом, чтобы степень связанности 
между системами оставаласьнизкой.
Степень связанности (coupling) — это мера, определяющая, насколько жестко один элемент связан с 
другими элементами, либо каким количеством данных о других элементах он обладает (ссылки на другие объекты).
Свойства элемента с низкой степенью связанности (слабым связыванием):
	- Малое число зависимостей между классами (подсистемами). 
	Кол-во ссылок на другие объекты в объявлении класса показывает степень связности,
	т.е. 1 ссылка - степень связности = 1, 2-е - степень связности = 2 и т.д.
	- Слабая зависимость одного класса (подсистемы) от изменений в другом классе (подсистеме).
	На основе абстракций, т.е. класс А зависит от интерфейса B и изменение реализации 
	интерфейса В не повлияет на класс А.
	- Высокая степень повторного использования подсистем.


* High Cohesion 
Класс, в котором каждая переменная используется каждым методом, обладает максимальной внутренней связностью.


* Polymorphism позволяет обрабатывать альтернативные варианты поведения на основе типа и заменять 
подключаемые компоненты системы, т.е. позволяет избежать написания явных условных операторов, 
когда есть объекты, поведение которых различно в зависимости от их типа.


* Pure Fabrication 
Класс, не отражающий никакого реального объекта предметной области, но специально придуманный для усиления 
внутренней связности, снижения внешней зависимости или увеличения степени повторного использования.
Например: DAO (Data Access Object)


* Indirection
Обеспечивает снижение внешней зависимости путём назначения обязанностей промежуточному объекту.
Пример: Controller в архитектуре Model-View-Controller


* Protected Variations защищает элементы от изменения других элементов, вынося взаимодействия в 
фиксированный интерфейс. Поведение может варьироваться лишь с помощью создания другой реализации 
интерфейса.





--------------------------------------------------------
--------------------------------------------------------





[CLEAN CODE PRINCIPLES]





[+] READABILITY


* Написать код, понятный компьютеру, может каждый, но только хорошие программисты пишут код, понятный людям.


* На самом деле соотношение времени чтения и написания кода превышает 10:1. Мы постоянно читаем свой 
старый код, поскольку это необходимо для написания нового кода. Упрощение чтения в действительности 
упрощает и написание кода.


* В основе поддержки читаемости и модифицируемости кода лежит РЕФАКТОРИНГ. Необходимо постоянно поддерживать 
чистоту кода путем постоянного РЕФАКТОРИНГа, т.к. некачественный код ведет к загниванию кодовой базы, снижению 
темпов и, в конечном итоге, полной остановке разработки. 


* "Правило бойскаута" гласит: все нужно оставлять чище, чем было до вашего прихода. Не существует модуля, 
который нельзя было бы улучшить, и каждый из нас обязан оставить чужой код хотя бы немного лучше, чем он был.
Код должен улучшаться каждый раз, когда мы над ним работаем.





[+] METHODS


* Первое правило: методы должны быть компактными. Второе правило: методы должны быть еще компактнее.


* МЕТОД ДОЛЖЕН ВЫПОЛНЯТЬ ТОЛЬКО ОДНУ ОПЕРАЦИЮ. ОН ДОЛЖЕН ВЫПОЛНЯТЬ ЕЕ ХОРОШО. И НИЧЕГО ДРУГОГО ОН ДЕЛАТЬ НЕ ДОЛЖЕН.
(SRP на уровне методов)


* В конце концов, методы пишутся прежде всего для разложения более крупной концепции (которая выражается 
именем метода) на последовательность действий (шагов) на следующем (более низком) уровне абстракции.


* В идеальном случае количество аргументов метода равно нулю (нуль-арный метод). Далее следуют методы с 
одним аргументом (унарные) и с двумя аргументами (бинарные). Методы с тремя аргументами  (тернарных) 
следует по возможности избегать. Необходимость методов с большим количеством аргументов (полиарных) 
должна быть подкреплена очень вескими доводами — и все равно такие методы лучше не использовать. 
Большое количество аргументов метода могут сигнализировать о нарушении SRP для данного метода.


* Если метод одного объекта должен изменять состояние другого объекта (функциональня зависть), 
то этот метод необходимо перенести в объект, состояние которого он изменяет.
Т.е. если метод f объекта A вызывает только методы объекта B и/или манипулирует состоянием объекта B, то 
метод f должен быть перенесен из объекта A в B (B1, p. 154 (Move Method)). 
Это в свою очередь увеличивает внутренюю связность объекта B (High Cohesion) и 
уменьшает внешнюю зависимость объектов A и B друг от друга (Low Coupling).


* Функциональная зависть - это один из "запахов кода", описанных у Мартина Фаулера 
(B1, p. 91 (Завистливые функции)). Для методов класса должны быть важны переменные и методы того 
класса, которому они принадлежат, а не переменные и методы других классов. Когда метод использует 
методы доступа другого объекта для манипуляций с его данными, то он завидует области видимости класса 
этого объекта. Он словно мечтает находиться в другом классе, чтобы иметь прямой доступ к переменным, 
с которыми он работает.  


* Либо метод изменяет состояние объекта, либо возвращает информацию об этом объекте, т.е. SRP. 
(B1, p. 282 (Separate Query from Modifier))


* Методы должны выполнять одну операцию (SRP). Обработка ошибок — это одна операция. Значит, метод, 
обрабатывающий ошибки, ничего другого делать не должен. Отсюда следует, что если в методе 
присутствует ключевое слово try, то оно должно быть первым словом в метода, а после блоков 
catch/finally ничего другого быть не должно.


* Локальный переменные метода следует объявлять как можно ближе к месту использования.


* Закон Деметры гласит, что метод f класса C должен ограничиваться вызовом методов следующих объектов:
	- C;
 	- объекты, созданные f;
 	- объекты, переданные f в качестве аргумента;
 	- объекты, хранящиеся в переменной экземпляра C.
Метод не должен вызывать методы объектов, возвращаемых любыми из разрешенных методов. Другими 
словами, ВЗАИМОДЕЙСТВОВАТЬ МОЖНО ТОЛЬКО С ДРУЗЬЯМИ, но не с чужаками.


* Если у вас возникает желание вернуть null из метода, рассмотрите возможность выдачи исключения 
или возвращения объекта "особого случая" (B1, p. 262 (Introduce Null Object)). 
Если ваш код вызывает метод стороннего API, способный вернуть null, создайте для него обертку в 
виде метода, который инициирует исключение или возвращает объект особого случая.


* Если один метод вызывает другой, то эти методы должны располагаться вблизи друг от друга по 
вертикали, а вызывающий метод должен находиться над вызываемым (если это возможно).


* Методам следует давать имена, раскрывающие их назначение. Хороший способ для этого – представить 
себе, каким должен быть комментарий к методу, и преобразовать этот комментарий в имя метода.


* Не комментируйте плохой код — перепишите его. Т.е. почувствовав потребность написать комментарий, 
попробуйте сначала изменить структуру кода так, чтобы любые комментарии стали излишними.


* Вместо комментария необходимо использовать соответствующее имя метода или переменной, чтобы 
код был самодокументирующим.


* Если ощущается необходимость что-то прокомментировать, надо написать метод. В таком методе содержится 
код, который требовал комментариев, но название этого метода отражает назначение кода, а не то, как он 
решает свою задачу. 


* Короткие методы не нуждаются в долгих описаниях. Хорошо выбранное имя компактного метода, 
который выполняет одну операцию (SRP) лучше заголовка с комментарием.





[+] CLASSES and OBJECTS


* Система должна состоять из множества мелких классов, а не из небольшого числа больших. Каждый 
класс инкапсулирует одну ответственность (SRP), имеет одну причину для изменения и взаимодействует 
с другими классами для реализации желаемого поведения системы.


* Чем меньше методов содержит класс, тем лучше. Чем меньше переменных экземпляров содержит класс, 
тем лучше. Большое число методов или переменных экземпляра могут сигнализировать о нарушении SRP.


* Класс, в котором каждая переменная используется каждым методом, обладает максимальной внутренней связностью 
(High Cohesion).


* Высокая связность означает, что методы и переменные класса взаимозависимы и существуют как единое целое.


* Подклассы создаются, чтобы добавить новое поведение или позволить поведению меняться. Если в подклассе 
поведение не изменяется/не добавляется, то подкласса необходимо отказаться.





[+] EXCEPTIONS


* Необходимо отказаться от проверяемых исключений. Цена проверяемых исключений — нарушение принципа 
открытости/закрытости (OCP). 
Т.е. при добавлении/изменении/удалении проверяемого исключения, кот. например, пробрасывается по цепочке 
вызовов нам придется ОТКРЫВАТЬ код классов и вносить изменения во все методы, кот. участвуют в данной 
цепочке вызовов.


* Проверяемые исключения иногда могут пригодиться при написании особо важных библиотек: программист 
обязан перехватить их. Но в общем случае разработки приложений проблемы, создаваемые зависимостями, 
перевешивают преимущества.





[+] TDD AND ARCHITECTURE (TESTS, IMPLEMENTATION, REFACTORING, TESTS)


* Возможность построить "правильную систему с первого раза" — миф. Вместо этого мы сегодня реализуем 
текущие потребности, а завтра перерабатываем и расширяем систему для реализации новых потребностей. 
В этом заключается суть итеративной, пошаговой, гибкой разработки. Разработка через ТЕСТИРОВАНИЕ, 
РЕФАКТОРИНГ и полученный в результате их применения ЧИСТЫЙ КОД обеспечивают работу этой схемы на уровне кода.


* Разумное и правильное проектное решение сегодня, через неделю может оказаться неправильным, т.к. по мере 
разработки системы выясняется необходимость в новых классах и перемещении функций между ними. Справиться с 
этим нам помогает РЕФАКТОРИНГ, т.к. перемещение состояний и поведения между классами составляет самую 
суть РЕФАКТОРИНГа.


* Важнейшее отличие программных систем от физических в том, что архитектура программных систем может 
развиваться последовательно, если обеспечить правильное разделение ответственности (GRASP).


* Независимо от того, проектируете ли вы целую систему или ее отдельные модули, помните: используйте 
САМОЕ ПРОСТОЕ РЕШЕНИЕ из всех возможных. Решение всегда можно изменить путем РЕФАКТОРИНГа при наличии 
набора качественных ТЕСТОВ.


* С применением РЕФАКТОРИНГа акценты смещаются. Предварительное проектирование сохраняется, но теперь оно не 
имеет целью найти единственно правильное решение. Все, что от него требуется, – это найти приемлемое решение. 
По мере реализации решения, с углублением понимания задачи становится ясно, что наилучшее решение отличается 
от того, которое было принято первоначально (так бывает ОЧЕНЬ часто). Но в этом нет ничего страшного, если в 
процессе участвует РЕФАКТОРИНГ, потому что модификация не обходится слишком дорого.
Важным следствием такого смещения акцентов является большее стремление к простоте проекта. 


* Обнаружив, что в программу необходимо добавить новую функциональность, но код программы не структурирован 
удобным для добавленния этой функциональности образом, сначала произведите РЕФАКТОРИНГ программы, чтобы 
упростить внесение необходимых изменений, а только потом добавьте функцию.


* Принимая решение в своем коде, убедитесь в том, что вы действуете предельно точно и аккуратно. 
ЗНАЙТЕ, ПОЧЕМУ ПРИНИМАЕТСЯ РЕШЕНИЕ, и как вы собираетесь поступать с исключениями из правила. 
Не ленитесь обеспечивать точность своих решений.


* Архитектура/код может считаться "простой" и "чистой", если она:
 	- обеспечивает прохождение всех тестов,
	- не содержит дублирующегося кода,
 	- выражает намерения программиста,
 	- использует минимальное количество классов и методов.


* Тестовый код не менее важен, чем код продукта. Не считайте его "кодом второго сорта". К написанию 
тестового кода следует относиться вдумчиво, внимательно и ответственно. Тестовый код должен быть 
таким же чистым, как и код продукта.


* ТЕСТИРОВАНИЕ повышает скорость программирования, т.к. комплект ТЕСТов служит мощным детектором ошибок, 
резко сокращающим время их поиска.


* Получив сообщение об ошибке, начните с создания ТЕСТа модуля, показывающего эту ошибку.


* Наличие надежных ТЕСТов является важным предварительным условием при проведении РЕФАКТОРИНГа.


* Дублирование — главный враг хорошо спроектированной системы. Его последствия — лишняя работа, лишний 
риск и лишняя избыточная сложность. 
Дублирование возникает как следствие нарушения SRP, т.к. одним из важнейших аспектов хорошей программной 
архитектуры является логическое разбиение кода — создание подходящих мест для размещения разных кодовых 
блоков. Разделение ответственности заметно упрощает понимание и сопровождение кода.


* Каждый раз, когда в программе встречается повторяющийся код, он указывает на упущенную возможность 
для АБСТРАКЦИИ. Возможно, дубликат мог бы стать методом или даже отдельным классом. "Сворачивая" дублирование 
в подобные абстракции, вы расширяете лексикон языка программирования. Другие программисты могут воспользоваться 
созданными вами абстрактными концепциями. Повышение уровня абстракции ускоряет программирование и снижает 
вероятность ошибок.


* Везде, где вы находите дублирующийся код, ищите возможности для ИНКАПСУЛЯЦИИ.


* Само объектно-ориентированное программирование может рассматриваться как стратегия модульной организации 
кода и устранения дубликатов.


* ИНКАПСУЛЯЦИЯ переменных аспектов делает код более гибким и упрощает его модификацию.


* DRY (Don’t repeat yourself) - каждый блок информации и поведения в системе должен существовать 
(быть ИНКАПСУЛИРОВАН) в одном разумно выбранном месте.


* Необходимо ИЗБЕГАТЬ ПРЕЖДЕВРЕМЕННОЙ ОПТИМИЗАЦИИ ПРОИЗВОДИТЕЛЬНОСТИ программ (кода) пока на это явно не укажет 
профайлер, т.к. оптимизированный код сожнее поддается РЕФАКТОРИНГу. Гораздо лучше, используя РЕФАКТОРИНГ, 
сначала получить программу, которую можно настраивать, а затем настроить ее так, чтобы достичь приемлемой 
производительности. (B1, p. 79 (Рефакторинг и производительность))





[+] DIFFERENCE BETWEEN OBJECTS AND DATA STRUCTURES (or difference between OOP and FUNCTIONAL paradigms)


* Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными. 
Структуры данных раскрывают свои данные и не имеют осмысленных функций (классический пример, DTO).


* Процедурный код (код, использующий структуры данных) позволяет легко добавлять новые функции без изменения 
существующих структур данных. 
Объектно-ориентированный код, напротив, упрощает добавление новых классов без изменения существующих функций.
Обратные утверждения также истинны.
Процедурный код усложняет добавление новых структур данных, потому что оно требует изменения всех функций. 
Объектно-ориентированный код усложняет добавление новых функций, потому что для этого должны измениться все классы.
Таким образом, то, что сложно в ОО, просто в процедурном программировании, а то, что сложно в процедурном 
программировании, просто в ОО.


* Если в некоторой системе нас прежде всего интересует гибкость в добавлении новых типов данных, то в этой 
части системы предпочтение отдается объектной реализации. Но если в других случаях нам нужна гибкость 
расширения поведения, и тогда в этой части используются структуры данных (например, обычный Java Bean, 
т.е. экземпляр класса, кот. содержит свойства, и GETTER'ы и SETTER'ы для них) и процедуры (наример, класс-сервис, 
который может не иметь состояния, но имеет множество методов для манипулирования данными, кот. хранятся в 
структуре данных). И хороший программист относится к этой проблеме без предубеждения и выбирает то решение, 
которое лучше всего подходит для конкретной ситуации.





[+] REFACTORING


* РЕФАКТОРИНГ - это изменение во внутренней структуре программного обеспечения (в коде), имеющее целью облегчить 
понимание его работы и упростить модификацию, не затрагивая наблюдаемого поведения.	


* Список рефакторингов (B1 p. 9)


* Ритм РЕФАКТОРИНГа: тестирование, малые изменения, тестирование, малые изменения, тестирование, малые изменения. 
Именно такой ритм делает рефакторинг быстрым и надежным.


* Перед началом РЕФАКТОРИНГа убедитесь, что располагаете надежным комплектом ТЕСТов. 


* РЕФАКТОРИНГ необходимо начинать с наимешей единицы функциональности - с МЕТОДА. 
Т.е. начинаем РЕФАКТОРИНГ с изучения МЕТОДОВ и применения рефакторингов относящихся к МЕТОДАМ:
Extract Method, Rename Method, Move Method и тд.


* Существует естественная связь между ПАТТЕРНАМИ ПРОЕКТИРОВАНИЯ и РЕФАКТОРИНГом. Паттерны представляют собой цели, 
а рефакторинг дает методы их достижения.











