
ï»¿

Books and sources:

[B1]: Learning SQL. Alan Beaulieu. 2009


--------------------------------------------------------
--------------------------------------------------------


mysql> SHOW TABLES;

mysql> DESC [table-name];



* Once the server has finished executing a query, the result set is returned to 
the calling application. This result set is just another table containing 
rows and columns. (B1, p. 57)



* A subquery serves the role of generating a temporary table that is visible
from all other query clauses and can interact with other tables named in the 
from clause. The subquery is referenced by the containing query via its alias, 
which, in this case, is e. (B1, p. 64-65)

mysql> SELECT e.emp_id, e.fname, e.lname
	-> FROM (SELECT emp_id, fname, lname, start_date, title
	-> FROM employee) e;

	
	
* A table (a result set) which is generated by a subquery can be joined via
JOIN in the same way as any other existing table. 
(See "Using Subqueries As Tables", B1 p. 105)

mysql> SELECT a.account_id, a.cust_id, a.open_date, a.product_cd
	-> FROM account a INNER JOIN
	->   (SELECT emp_id, assigned_branch_id
	->      FROM employee
	->      WHERE start_date < '2007-01-01'
	->      AND (title = 'Teller' OR title = 'Head Teller')) e
	->   ON a.open_emp_id = e.emp_id
	->   INNER JOIN
	->     (SELECT branch_id
	->       FROM branch
	->       WHERE name = 'Woburn Branch') b
	->   ON e.assigned_branch_id = b.branch_id;



* Self-Joins. We can join a table to itself (B1, p. 108):

mysql> SELECT e.fname, e.lname,
	-> e_mgr.fname mgr_fname, e_mgr.lname mgr_lname
	-> FROM employee e INNER JOIN employee e_mgr
	-> ON e.superior_emp_id = e_mgr.emp_id;
	
	

* UNION (B1, p. 118)

mysql> SELECT 1 num, 'abc' str
	-> UNION
	-> SELECT 9 num, 'xyz' str;



* INTERSECT (B1, p. 121)

mysql> SELECT emp_id, fname, lname
	-> FROM employee
	-> INTERSECT
	-> SELECT cust_id, fname, lname
	-> FROM individual;
	
	
	
* EXCEPT (B1, p. 122)

mysql> SELECT emp_id
	-> FROM employee
	-> WHERE assigned_branch_id = 2
	->  AND (title = 'Teller' OR title = 'Head Teller')
	-> EXCEPT
	-> SELECT DISTINCT open_emp_id
	-> FROM account
	-> WHERE open_branch_id = 2;



* Multicolumn Grouping (B1, p. 166)

mysql> SELECT product_cd, open_branch_id,
	-> SUM(avail_balance) tot_balance
	-> FROM account
	-> GROUP BY product_cd, open_branch_id;



* Group Filter Conditions (B1, p. 170):
When adding filters to a query that includes a group by clause, think carefully 
about whether the filter acts on raw data, in which case it belongs in the 
WHERE clause, or on grouped data, in which case it belongs in the HAVING clause.

mysql> SELECT product_cd, SUM(avail_balance) prod_balance
	-> FROM account
	-> WHERE status = 'ACTIVE'
	-> GROUP BY product_cd
	-> HAVING SUM(avail_balance) >= 10000;
	
	

* It is possible to include aggregate functions in the having clause, 
that do not appear in the select clause (B1, p. 170):

mysql> SELECT product_cd, SUM(avail_balance) prod_balance
	-> FROM account
	-> WHERE status = 'ACTIVE'
	-> GROUP BY product_cd
	-> HAVING MIN(avail_balance) >= 1000
	-> AND MAX(avail_balance) <= 10000;
	
	
	
* Correlated Subqueries (B1, p. 182):
A correlated subquery is dependent on its containing statement from
which it references one or more columns. 

mysql> SELECT c.cust_id, c.cust_type_cd, c.city
	-> FROM customer c
	-> WHERE 2 = (SELECT COUNT(*)
	-> FROM account a
	-> WHERE a.cust_id = c.cust_id);
	
	

* Subqueries As Data Sources (B1, p. 187)

mysql> SELECT d.dept_id, d.name, e_cnt.how_many num_employees
	-> FROM department d 
	-> INNER JOIN
	-> (SELECT dept_id, COUNT(*) how_many
	-> 	FROM employee
	-> 	GROUP BY dept_id) e_cnt
	-> ON d.dept_id = e_cnt.dept_id;
	
	

* Table population using subqueries (B1, p. 195)

mysql> INSERT INTO account
	->  (account_id, product_cd, cust_id, open_date, last_activity_date,
	->  status, open_branch_id, open_emp_id, avail_balance, pending_balance)
	-> VALUES (NULL,
	->  (SELECT product_cd FROM product WHERE name = 'savings account'),
	->  (SELECT cust_id FROM customer WHERE fed_id = '555-55-5555'),
	->  '2008-09-25', '2008-09-25', 'ACTIVE',
	->  (SELECT branch_id FROM branch WHERE name = 'Quincy Branch'),
	->  (SELECT emp_id FROM employee WHERE lname = 'Portman' AND fname = 'Frank'),
	->  0, 0);
	
	
	
* OUTER JOINs: LEFT OUTER JOIN & RIGHT OUTER JOIN (B1, p. 198)



* Conditional logic (B1, p. 223):

mysql> SELECT
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2000 THEN 1
	-> 		ELSE 0
	-> 	END) year_2000,
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2001 THEN 1
	-> 		ELSE 0
	-> 	END) year_2001,
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2002 THEN 1
	-> 		ELSE 0
	-> 	END) year_2002,
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2003 THEN 1
	-> 		ELSE 0
	-> 	END) year_2003,
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2004 THEN 1
	-> 		ELSE 0
	-> 	END) year_2004,
	-> 	SUM(CASE
	-> 		WHEN EXTRACT(YEAR FROM open_date) = 2005 THEN 1
	-> 		ELSE 0
	-> 	END) year_2005
	-> FROM account
	-> WHERE open_date > '1999-12-31' AND open_date < '2006-01-01';



* Checking for Existence (B1, p. 226)

mysql> SELECT c.cust_id, c.fed_id, c.cust_type_cd,
	-> CASE
	-> WHEN EXISTS (SELECT 1 FROM account a
	-> WHERE a.cust_id = c.cust_id
	-> AND a.product_cd = 'CHK') THEN 'Y'
	-> ELSE 'N'
	-> END has_checking,
	-> CASE
	-> WHEN EXISTS (SELECT 1 FROM account a
	-> WHERE a.cust_id = c.cust_id
	-> AND a.product_cd = 'SAV') THEN 'Y'
	-> ELSE 'N'
	-> END has_savings
	-> FROM customer c;




