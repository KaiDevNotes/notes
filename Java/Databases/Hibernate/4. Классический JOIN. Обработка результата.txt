Пример основан на структуре сущностей: КОНТИНЕНТ, ЛОКАЦИЯ и СЕРВЕР, реализованной в примере "Hibernate full example"

После создания сущности хранятся в следующих таблицах БД:

CONTINENTS
|-------|-------------------|
|	ID	|	NAME			|		
|-------|-------------------|
|	1	|	North America	|
|-------|-------------------|
|	2	|	Europe			|
|-------|-------------------|
|	3	|	Australia		|
|-------|-------------------|

LOCATIONS
|-------|-----------------------|-------------------|
|	ID	|	NAME				|	CONTINENT_ID	|		
|-------|-----------------------|-------------------|
|	1	|	USA, New York		|		1			|
|-------|-----------------------|-------------------|
|	2	|	Germany, Berlin		|		2			|
|-------|-----------------------|-------------------|
|	3	|	Australia			|		3			|
|-------|-----------------------|-------------------|

SERVERS
|-------|-----------------------|-------------------|
|	ID	|	NAME				|	LOCATION_ID		|		
|-------|-----------------------|-------------------|
|	1	|	Server #1.1			|		1			|
|-------|-----------------------|-------------------|
|	2	|	Server #1.2			|		1			|
|-------|-----------------------|-------------------|
|	3	|	Server #2.1			|		2			|
|-------|-----------------------|-------------------|
|	4	|	Server #2.2			|		2			|
|-------|-----------------------|-------------------|
|	5	|	Server #3.1			|		3			|
|-------|-----------------------|-------------------|
|	6	|	Server #3.2			|		3			|
|-------|-----------------------|-------------------|


Если, например, в MySQL Workbanch выполнить запрос на получение всех КОНТИНЕНТОВ, связанных с ними ЛОКАЦИЙ и связанных с ЛОКАЦИЯМИ СЕРВЕРОВ:

SELECT * FROM continents
LEFT JOIN locations ON locations.CONTINENT_ID = continents.id
LEFT JOIN servers ON servers.LOCATION_ID = locations.id; 

то получим следующий результат:

|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	ID	|	NAME			|	ID	|	NAME				|	CONTINENT_ID	|	ID	|	NAME				|	LOCATION_ID		|	
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	1	|	North America	|	1	|	USA, New York		|		1			|	1	|	Server #1.1			|		1			|
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	1	|	North America	|	1	|	USA, New York		|		1			|	2	|	Server #1.2			|		1			|
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	2	|	Europe			|	2	|	Germany, Berlin		|		2			|	3	|	Server #2.1			|		2			|
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	2	|	Europe			|	2	|	Germany, Berlin		|		2			|	4	|	Server #2.2			|		2			|
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	3	|	Australia		|	3	|	Australia			|		3			|	5	|	Server #3.1			|		3			|		
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|
|	3	|	Australia		|	3	|	Australia			|		3			|	6	|	Server #3.2			|		3			|		
|-------|-------------------|-------|-----------------------|-------------------|-------|-----------------------|-------------------|



Такой же запрос к БД можно сформировать с помощию Hibernate HQL:
---------
List<Object[]> result = session.createQuery("FROM Continent C LEFT JOIN C.locations L LEFT JOIN L.servers S").list();
---------

Для вывода результат в консоли используем следующий код:
---------
for (Object[] o : result){
	Continent c = (Continent) o[0];
	Location l = (Location) o[1];
	Server s = (Server) o[2];
	System.out.print("CONTINENT ID: "+c.getId()+" -- COTINENT NAME: "+c.getName()+"  | ");
	System.out.print("LOCATION ID: "+l.getId()+" -- LOCATION NAME: "+l.getName()+" | ");
	System.out.println("SERVER ID: "+s.getId()+" -- SERVER NAME: "+s.getName());
}
---------

В результате в консоли получаем следующий результат:

-----------------------------
CONTINENT ID: 1 -- COTINENT NAME: North America | LOCATION ID: 1 -- LOCATION NAME: USA, New York 		| SERVER ID: 1 -- SERVER NAME: Server #1.1
CONTINENT ID: 1 -- COTINENT NAME: North America | LOCATION ID: 1 -- LOCATION NAME: USA, New York 		| SERVER ID: 2 -- SERVER NAME: Server #1.2
CONTINENT ID: 2 -- COTINENT NAME: Europe  		| LOCATION ID: 2 -- LOCATION NAME: Germany, Berlin 		| SERVER ID: 3 -- SERVER NAME: Server #2.1
CONTINENT ID: 2 -- COTINENT NAME: Europe  		| LOCATION ID: 2 -- LOCATION NAME: Germany, Berlin 		| SERVER ID: 4 -- SERVER NAME: Server #2.2
CONTINENT ID: 3 -- COTINENT NAME: Australia  	| LOCATION ID: 3 -- LOCATION NAME: Australia, Canberra 	| SERVER ID: 5 -- SERVER NAME: Server #3.1
CONTINENT ID: 3 -- COTINENT NAME: Australia  	| LOCATION ID: 3 -- LOCATION NAME: Australia, Canberra 	| SERVER ID: 6 -- SERVER NAME: Server #3.2
-----------------------------


ВЫВОД:

1) Результатом "классического" JOIN является коллекция массивов типа Object.

2) Каждый элемент коллекции-результата (Object[]) представляет собой одну строку результата.

3) Каждый объект в массиве Object[] необходимо приводить к нужному типу данных, в порядке запроса.
Т.е. если мы запрашиваем КОНТИНЕТЫ, связ. с ними ЛОКАЦИИ и связ. с каждой ЛОКАЦИЕЙ СЕРВЕРА, то в такой же послевовательности мы и приводим объекты массива к необходимому типу:
Continent c = (Continent) o[0];
Location l = (Location) o[1];
Server s = (Server) o[2];

Приведение необходимо производить вручную т.к. Hibernate в данном случае не может это делать самостоятельно, он не знает к какому из связанных типов данных приводить те или иные куски результата.

4) В данном примере это не иллюстрируется, но один из элементов (объектов) строки результата, т.е. массива Object[] может быть равен null и это НЕОБХОДИМО ПРОВЕРЯТЬ.
